# Справочник Юного Волшебника GLSL: Твой Путь в Мир Графических Заклинаний!

Привет, юный маг и чародей! Добро пожаловать в удивительный мир графической магии! В этом справочнике ты найдёшь всё, что нужно, чтобы научиться создавать потрясающие визуальные эффекты на экране компьютера.

## Раздел 1: Что такое GLSL?

**GLSL** (OpenGL Shading Language) — это как секретный язык заклинаний, который понимают компьютеры с видеокартами. С его помощью ты можешь управлять цветами, формами, светом и другими визуальными элементами. Это как если бы ты мог рисовать волшебной кистью прямо на экране, создавая невероятные картины и миры!

## 1.1 О чём этот Справочник?

Этот справочник — твой верный спутник в путешествии по миру GLSL. В нём ты найдёшь ответы на самые важные вопросы:

*   **Переменные:** Как хранить волшебные числа и цвета в специальных коробочках.
*   **Типы Данных:** Какие бывают волшебные "вещи", которые можно хранить.
*   **Функции и Методы:** Как создавать волшебные машины, которые делают полезные вещи.
*   **Параметры:** Как передавать команды этим машинам.
*   **Главная Функция:** Как заставить всё работать вместе.
* **Математика**: Какие волшебные знаки использовать для сложения, умножения и других действий.
* **Цвета**: Как управлять цветом.
*   **И многое другое!**

## 1.2 Для Кого Этот Справочник?

Этот справочник написан специально для начинающих волшебников, которые только начинают свой путь в мир графики. Если ты хочешь:

*   Узнать, как создаются красивые визуальные эффекты в компьютерных играх.
*   Научиться управлять цветами и формами на экране.
*   Сделать свои собственные "волшебные" программы.
*   Или просто хочешь понять, как всё это работает.

Тогда этот справочник точно для тебя!

## 1.3 Как Пользоваться Справочником?

Читай разделы по порядку, но не бойся заглядывать вперёд или возвращаться назад. Самое главное — экспериментируй! Пробуй разные команды, смотри, что получается, и не бойся ошибаться. Только так ты станешь настоящим Мастером GLSL!

## 1.4 Открываем Дверь в Волшебство!

Вперёд, юный маг!  Впереди тебя ждут удивительные открытия и невероятные творения! Помни: всё, что тебе нужно — это воображение и желание учиться! И, конечно же, этот справочник!

## Раздел 2: Волшебные Коробочки, или Что Такое Переменные?

В мире GLSL, как и в любом другом мире магии, нам нужно уметь хранить разные волшебные вещи: числа, цвета, координаты и многое другое. Для этого мы используем **переменные**. Представь, что переменные — это такие волшебные коробочки, куда ты можешь класть разные вещи.

### 2.1 Имя Коробочки

У каждой коробочки (переменной) должно быть **имя**, чтобы мы знали, где какая вещь лежит. Имена могут быть разными: `myNumber`, `myColor`, `myPosition`, `energy`, `type`. Главное, чтобы имя было понятным, чтобы мы сами не запутались!

**Правила для Имени:**

*   Имя может состоять из букв, цифр и знака подчеркивания (`_`).
*   Имя должно начинаться с буквы или знака подчеркивания.
*   Нельзя использовать пробелы в имени.
* Нельзя что бы имя совпадало с именем `типа данных` о которых ты узнаешь дальше.

**Хорошие имена:**

*   `myAge`
*   `numberOfStars`
*   `player_health`

**Плохие имена:**

*   `123number` (начинается с цифры)
*   `my number` (есть пробел)
* `float` (совпадает с типом данных)

### 2.2 Тип Коробочки: Какие Волшебные Вещи мы Можем Хранить?

Перед тем, как положить что-то в коробочку, мы должны сказать, что именно там будет храниться. Это называется **типом данных**. В GLSL есть несколько основных типов:

*   **`int`:** Коробочки для целых чисел. Как количество конфет в пакете: `1`, `2`, `100`, `-5`.
    ```glsl
    int numberOfLives = 3; // У игрока 3 жизни
    ```
*   **`float`:** Коробочки для дробных чисел. Как вес торта: `3.14`, `2.5`, `0.75`, `-1.25`.
    ```glsl
    float playerSpeed = 5.5; // Скорость игрока 5.5
    ```
*   **`bool`:** Коробочки для правды или лжи. Как лампочка: `true` (включена) или `false` (выключена).
    ```glsl
    bool isGameOver = false; // Игра закончена? Нет! (ложь)
    ```
*   **`vec2`:** Коробочки для двух чисел вместе. Как координаты на карте (X, Y).
    ```glsl
    vec2 playerPosition = vec2(10.0, 20.0); // Игрок находится в точке (10, 20)
    ```
*   **`vec3`:** Коробочки для трёх чисел вместе. Как цвет (Красный, Зелёный, Синий).
    ```glsl
    vec3 myColor = vec3(1.0, 0.0, 0.0); // Красный цвет
    ```
*   **`vec4`:** Коробочки для четырёх чисел вместе. Как цвет с прозрачностью (Красный, Зелёный, Синий, Прозрачность).
    ```glsl
    vec4 myTransparentColor = vec4(0.0, 0.0, 1.0, 0.5); // Синий цвет наполовину прозрачный
    ```
* **`ivec2`, `ivec3`, `ivec4`:** Коробочки для двух, трёх или четырех *целых* чисел вместе. Работают как `vec` но содержат только целые числа.
   ```glsl
   ivec2 mySize = ivec2(10,20);// Ширина и высота

### 2.3 Создание Коробочки и Помещение в Неё Вещи

```glsl
Чтобы создать коробочку, нужно сказать её тип, а потом дать ей имя:
int myAge; // Создали коробочку для целого числа с именем myAge.
float myWeight; // Создали коробочку для дробного числа с именем myWeight.
vec3 mySkyColor; // Создали коробочку для цвета (из 3 чисел) с именем mySkyColor.
```
А чтобы положить что-то в коробочку, нужно использовать знак равенства (=):
```glsl
int myAge = 10; // Создали коробочку myAge и положили в неё число 10.
float myWeight = 30.5; // Создали коробочку myWeight и положили в неё число 30.5.
vec3 mySkyColor = vec3(0.2, 0.5, 1.0); // Создали коробочку mySkyColor и положили в неё синий цвет.
```

### 2.4 Массивы: Много Коробочек в Одном Рюкзаке

Иногда нам нужно хранить много похожих вещей. Например, цвета для всех клеток на игровом поле. Тогда мы используем массивы. Представь, что массив — это такой рюкзак с отделениями, где в каждом отделении лежит своя коробочка.
Создание Рюкзака:
```glsl
int birthCounts[9]; // Рюкзак для 9 целых чисел с именем birthCounts.
vec3 colors[10]; // Рюкзак для 10 цветов с именем colors.
float myNumbers[5]; // Рюкзак для 5 дробных чисел с именем myNumbers.
```
- int birthCounts[9]: Создали рюкзак с именем birthCounts, в котором 9 отделений, и в каждом отделении может лежать целое число.
- []: В квадратных скобках указываем сколько отделений у нашего рюкзака.
Положить Что-то в Отделение:
В каждом отделение у нас своя коробочка. Для того что бы положить что то в определенное отделение надо указать его номер.
```gls
birthCounts[0] = 0; // В нулевое отделение положили число 0.
birthCounts[1] = 0; // В первое отделение положили число 0.
birthCounts[2] = 0; // В второе отделение положили число 0.
// и так далее..
colors[0] = vec3(1.0, 0.0, 0.0); // В нулевое отделение положили красный цвет.
myNumbers[4] = 3.14; // В пятое отделение положили число 3.14.
```
* **Важно**: Отделения в рюкзаке нумеруются с 0! То есть, у рюкзака из 9 отделений, первое отделение имеет номер 0, а последнее — номер 8.

### 2.5 Итог

Теперь ты знаешь, что такое переменные и массивы! Ты знаешь, что в них можно хранить разные типы данных. Это очень важные знания, которые помогут тебе создавать настоящую графическую магию!

**Что дальше**:

В следующем разделе мы узнаем, как создавать волшебные машины (функции) и как они работают!

## Раздел 3: Волшебные Машины: Функции и Процедуры

В мире GLSL, чтобы творить настоящую графическую магию, нам нужны не только волшебные коробочки (переменные), но и волшебные машины, которые умеют делать что-то полезное. Такие машины называются **функциями** или **процедурами**.

### 3.1 Функции: Машины с Результатом

Представь, что **функция** — это такая волшебная машина, которой ты даёшь что-то на вход (например, числа или цвета), а она что-то делает и возвращает тебе результат. Это как машина, которая получает на вход муку, воду и яйца, а на выходе выдаёт готовый пирожок!

*   **Имя:** У каждой машины есть имя, чтобы мы знали, какую машину использовать. Например, `addNumbers`, `mixColors`.
*   **Параметры:** Это то, что мы кладём в машину на вход. Например, два числа.
*   **Возвращаемое значение:** Это то, что машина нам отдаёт. Например, сумма чисел или новый цвет.
*   **Тело функции:** Это то что происходит в машине, магия которая преобразует параметры в выходные данные.

**Как выглядит машина (функция) в GLSL:**

```glsl
// Эта машина умеет складывать два числа.
float addNumbers(float a, float b) { // Имя: addNumbers, Параметры: a и b, тип float.
    float sum = a + b; // Магия сложения!
    return sum; // Машина возвращает сумму.
}
```

**Объяснение**:

1. **float**: Это тип возвращаемого значения. Машина addNumbers всегда будет возвращать дробное число (float).
2. **addNumbers**: Это имя машины. Мы будем использовать его, когда захотим запустить эту машину.
3. **(float a, float b)**: Это параметры машины.
  - **float a**: В машину можно положить дробное число, и внутри машины оно будет называться a.
  - **float b**: Ещё одно дробное число, которое будет называться b.
4. **{ ... }**: В фигурных скобках заключено "тело функции" — все те действия, которые выполняет машина.
5. **float sum = a + b;**: Здесь мы складываем числа a и b и результат кладём в новую коробочку (переменную) с именем sum.
6. **return sum;**: Это волшебное слово return! Оно говорит машине, что пора отдавать результат, который хранится в коробочке sum.

**Дополнительно о фигурных скобках `{}`:**

В GLSL фигурные скобки `{}` — это как волшебные границы, которые говорят, где начинается и где заканчивается тело машины (функции) или тело цикла или условия о которых мы поговорим позже. Всё, что находится *внутри* фигурных скобок, относится к этой машине, циклу или условию.

Например, в теле функции `addNumbers`  все действия, которые происходят с числами `a` и `b`, заключены в `{}`:

```glsl
float addNumbers(float a, float b) {
    float sum = a + b; // Магия сложения!
    return sum; // Машина возвращает сумму.
}
```

Точно так же в телах условий и циклов:

```glsl
if(a>b){ // тело условия
    // если условие правда то этот код выполняется.
}
for(int i = 0; i < 5; i++){//тело цикла
    // этот код повторяется 5 раз
}
```

Помни, что фигурные скобки — очень важны! Без них компьютер не поймёт, где начинается и где заканчивается тело.



### 3.2 Процедуры: Машины Без Результата

Теперь представь, что процедура — это машина, которая что-то делает, но ничего тебе не возвращает. Это как машина, которая просто моет посуду: она делает свою работу, но ничего тебе не отдаёт.

**Имя**: То же самое, что и у функций.
Параметры: То же самое, что и у функций.
Нет возвращаемого значения: Процедура ничего не возвращает!
Тело процедуры: То же самое что и в теле функции.

Как выглядит процедура в **GLSL**:

```gls
// Эта машина просто рисует круг. Она ничего не возвращает.
void drawCircle(float centerX, float centerY, float radius) { // Имя: drawCircle, Параметры: centerX, centerY, radius, тип float.
    // ... Магия рисования круга ...
    // тут происходит что то но ни чего не возвращается.
}
```

**Объяснение**:

1. **void**: Это тип возвращаемого значения. Процедура drawCircle ничего не возвращает.
2. **drawCircle**: Это имя процедуры.
3. **(float centerX, float centerY, float radius)**: Это параметры процедуры.
  - **float centerX**: В процедуру можно положить дробное число, и внутри процедуры оно будет называться centerX.
  - **float centerY**: Ещё одно дробное число, которое будет называться centerY.
  - **float radius**: И ещё одно дробное число, которое будет называться radius.
4. **{ ... }**: В фигурных скобках заключено "тело процедуры" — тут происходит магия, но ни чего не возвращается.

### 3.3 Чем Функция Отличается от Процедуры?

* **Функция**: Всегда что-то возвращает. В ней всегда есть слово return.
* **Процедура**: Ничего не возвращает. Вместо типа возвращаемого значения у неё написано void.
* **Название**: В GLSL нет чёткого разделения, всё что мы опишем, будет просто функцией. Но если она ни чего не возвращает то мы её называем процедурой.

### 3.4 Параметры: То что мы Кладём в Машину?

Когда мы хотим запустить машину (вызвать функцию или процедуру), мы можем положить в неё разные вещи — передать ей разные значения. Эти значения называются параметрами.

**Примеры**:
```gls
float result = addNumbers(5.0, 3.0); // Передаём в машину addNumbers два числа: 5.0 и 3.0
float mult = multiplyNumbers(10.0, 2.0); // Передаём в машину multiplyNumbers два числа: 10.0 и 2.0
drawCircle(1.5, 2.0, 0.5); // Передаём в машину drawCircle три числа: 1.5, 2.0 и 0.5
```

**В этом случае**:

**5.0 ** и **3.0** - это параметры для addNumbers.
**10.0** и **2.0** - это параметры для multiplyNumbers.
**1.5**, **2.0** и **0.5** - это параметры для drawCircle.

### 3.5 Итог

Теперь ты знаешь, что такое функции и процедуры! Ты знаешь, как их создавать, как передавать им параметры и чем они отличаются! Это очень важные знания для любого волшебника GLSL!

**Что дальше**:
В следующем разделе мы узнаем, как работает самая главная машина в GLSL — функция main!

## Раздел 4: Главная Машина `main` и Волшебные Знаки (Операторы)

В мире GLSL, как и в любом волшебном мире, есть что-то самое главное, что запускает всю магию.  В GLSL это **главная машина**, которая называется `main`. Именно с неё начинается выполнение всех твоих заклинаний.  А ещё, в этом разделе мы узнаем про **волшебные знаки** (их ещё называют **операторами**), которые помогают нам творить чудеса.

### 4.1 Главная Машина: Функция `main`

Представь, что функция `main` — это волшебная кнопка "Пуск", которая запускает всё-всё-всё. Именно в ней ты будешь вызывать все свои волшебные машины (функции и процедуры) и делать самые крутые графические эффекты.

**Как выглядит главная машина в GLSL:**

```glsl
void main() {
    // ... Здесь будет происходить вся магия! ...
    // Тут ты будешь вызывать свои функции и процедуры.
    // менять значения переменных и многое другое.
}
```
**Объяснение:**

1.  **`void`:** Помнишь, что это значит? Это говорит о том, что главная машина `main` ничего не возвращает. Она просто запускает другие действия.
2.  **`main`:** Это имя главной машины. Оно всегда одно и то же — `main`.
3.  **`()`:** В скобках мы ничего не пишем, потому что главная машина не принимает никаких параметров.
4.  **`{ ... }`:** В фигурных скобках — "тело" главной машины. Здесь ты будешь писать все свои заклинания (команды).

**Что можно делать в главной машине:**

*   **Вызывать другие функции и процедуры:** Например, `addNumbers(5.0, 3.0)` или `drawCircle(1.5, 2.0, 0.5)`.
*   **Создавать и изменять переменные:** Например, `float myEnergy = 10.0;` или `myColor = vec3(1.0, 0.0, 0.0);`.
*   **Делать много других волшебных вещей!**

### 4.2 Волшебные Знаки (Операторы)

Чтобы творить магию, нам нужны волшебные знаки. Они называются **операторами**. Вот самые важные из них:

**Математические Знаки:**

*   **`+`:** Сложение. Например, `5 + 3` (получится `8`).
*   **`-`:** Вычитание. Например, `10 - 4` (получится `6`).
*   **`*`:** Умножение. Например, `2 * 6` (получится `12`).
*   **`/`:** Деление. Например, `10 / 2` (получится `5`).
*   **`%`:** Остаток от деления. Например, `10 % 3` (Получится `1`).
*   **`=`:** Знак присвоения. Положить что то в коробочку. Например `int myVar = 10;`.
*   **`+=`, `-=`, `*=`, `/=`:** Удобная запись:
    *   `myVar += 5` - Это то же самое что и `myVar = myVar + 5`.
    *   `myVar -= 5` - Это то же самое что и `myVar = myVar - 5`.
    *   `myVar *= 5` - Это то же самое что и `myVar = myVar * 5`.
    *   `myVar /= 5` - Это то же самое что и `myVar = myVar / 5`.

**Знаки Сравнения:**

*   **`>`:** Больше. Например, `5 > 3` (правда).
*   **`<`:** Меньше. Например, `2 < 4` (правда).
*   **`>=`:** Больше или равно. Например, `5 >= 5` (правда).
*   **`<=`:** Меньше или равно. Например, `3 <= 4` (правда).
*   **`==`:** Равно. Например, `10 == 10` (правда).
*   **`!=`:** Не равно. Например `5 != 10` (Правда).

**Логические Знаки:**

*   **`&&`:** И. Правда, если оба условия правдивы. Например, `(5 > 3) && (2 < 4)` (правда).
*   **`||`:** ИЛИ. Правда, если хотя бы одно из условий правдиво. Например, `(5 < 3) || (2 < 4)` (правда).
*   **`!`:** НЕ. Инвертирует значение. Если правда то станет ложью, а если ложь то станет правдой. Например `!false` (Правда).

**Примеры использования знаков:**

```glsl
void main() {
    float myNumber = 10.0; // Положили 10 в коробочку myNumber.
    myNumber = myNumber + 5.0; // Добавили 5 к myNumber. Теперь там 15.
    bool isBig = myNumber > 12.0; // Теперь isBig - правда, потому что 15 больше 12.
    float sum = 5.0 + 3.0;// Сложили 5.0 и 3.0, и положили результат в sum
    int myVar = 10;
    myVar += 5;// тоже самое что и myVar = myVar + 5
}
```
### 4.3 Условия

Что бы проверять значения нам нужны условия, с их помощью мы можем проверять что правда а что нет, и в зависимости от этого выполнять разные действия.

Что бы создать условие, нам нужно использовать `if`.

**Как это выглядит:**

```glsl
if(условие){ // если условие правдиво, то будет выполнено то что внутри.
 // тут происходит магия если условие правдиво
}
```

**Пример**:

```glsl
if(myVar > 10){ // Если значение myVar больше 10
// что то происходит
}
```

**Сложные условия**:
Мы можем использовать несколько условий сразу, с помощью **else if**:

```glsl
if(myVar > 10){ // Если значение myVar больше 10
// что то происходит
} else if(myVar < 5){// Если значение myVar меньше 5
// что то происходит
}
```

**Что происходит в этом случае**:
* Сперва проверяется первое условие, если оно правдиво то код будет выполнен. И на этом всё закончится.
* Если первое условие не верно, то проверяется второе условие. И если оно верно, то код будет выполнен.

**Если не одно из условий не подошло**

Мы можем указать что делать, если не одно из условий не подошло. С помощью else:

```glsl
if(myVar > 10){ // Если значение myVar больше 10
// что то происходит
} else if(myVar < 5){// Если значение myVar меньше 5
// что то происходит
} else {//Если не одно из условий не подошло, то будет выполнено это
// что то происходит
}
```

### 4.4 Циклы

Иногда нам нужно повторить одни и те же действия много раз. Для этого в GLSL есть **циклы**. Представь, что цикл — это такая волшебная петля, которая заставляет код повторяться снова и снова, пока мы не скажем ему остановиться.

В GLSL есть цикл `for`.

**Как он выглядит:**

```glsl
for(начало; условие; шаг){ // тут происходит магия пока условие правдиво
// код который повторяется
}
```

**Объяснение:**

1.  **`for`:** Это волшебное слово, которое говорит, что мы начинаем цикл.
2.  **(начало; условие; шаг):** В скобках три части, разделённые точкой с запятой (`;`):
    *   **`начало`:** Что-то, что делается *один раз* перед началом цикла. Обычно здесь создают коробочку (переменную) со счётчиком.
    *   **`условие`:** Пока это условие *правдиво*, цикл повторяется. Как только условие становится *ложным*, цикл заканчивается.
    *   **`шаг`:** Что-то, что делается в *конце* каждого повторения цикла. Обычно здесь мы меняем значение счётчика.
3.  **( { ... }):** В фигурных скобках — код, который будет повторяться.

**Пример:**

```glsl
for(int i = 0; i < 5; i++){//повтори 5 раз
//... тут происходит магия...
}
```

**Объяснение примера:**

1.  `int i = 0;` **(начало):** Мы создаём коробочку (переменную) с именем `i` и кладем в неё число `0`. Это наш счётчик.
2.  `i < 5;` **(условие):** Цикл будет повторяться, пока значение `i` *меньше* `5`.
3.  `i++` **(шаг):** В конце каждого повторения цикла мы увеличиваем `i` на `1` (`i++` — это то же самое, что `i = i + 1`).
4. В итоге этот код повторится 5 раз. Счётчик i будет от 0 до 4.

**Другой пример:**

```glsl
void main(){
    for(float x = 0.0; x < 1.0; x+=0.1){
        //Тут происходит магия с x.
    }
}
```

**Объяснение другого примера:**

1.  `float x = 0.0;` **(начало):** Мы создаём коробочку (переменную) с именем `x` и кладем в неё дробное число `0.0`. Это наш счётчик.
2.  `x < 1.0;` **(условие):** Цикл будет повторяться, пока значение `x` *меньше* `1.0`.
3.  `x+=0.1` **(шаг):** В конце каждого повторения цикла мы увеличиваем `x` на `0.1` (`x+=0.1` — это то же самое, что `x = x + 0.1`).
4. В итоге этот код повторится 10 раз. Счётчик x будет от 0.0 до 0.9.

### 4.5 Итог

Теперь ты знаешь, что такое главная машина `main`, какие бывают волшебные знаки (операторы) и что такое циклы!  С их помощью ты можешь делать в GLSL почти всё что угодно!

```glsl
void main(){
   //Тут ты можешь использовать все свои знания.
}
```

В этом разделе ты узнал что:

*  Главная машина `main`, это место где всё начинается.
* Как работают операторы.
* Как работают условия.
* Как работают циклы.

Теперь ты знаешь все базовые вещи что бы управлять своим кодом.


## Раздел 5: Магия Цветов

В мире GLSL цвет — это очень важная вещь! Ведь именно цвета делают нашу графику красивой и интересной. В этом разделе мы узнаем, как создавать, смешивать и изменять цвета.

### 5.1 Как хранить цвета?

Для хранения цветов в GLSL мы используем волшебные коробочки типа `vec3` или `vec4`.

*   **`vec3`:**  Три числа вместе — красный, зелёный, синий (R, G, B). Каждое число может быть от `0.0` (совсем нет цвета) до `1.0` (полный цвет).
    *   Например:
        *   `(1.0, 0.0, 0.0)` — Красный цвет.
        *   `(0.0, 1.0, 0.0)` — Зелёный цвет.
        *   `(0.0, 0.0, 1.0)` — Синий цвет.
        *   `(1.0, 1.0, 0.0)` - Желтый цвет.
        * `(0.0, 1.0, 1.0)` - Голубой цвет.
        * `(1.0, 0.0, 1.0)` - Фиолетовый цвет.
        *  `(1.0,1.0,1.0)` - Белый цвет.
        * `(0.0,0.0,0.0)` - Чёрный цвет.
*   **`vec4`:**  Четыре числа вместе — красный, зелёный, синий и *прозрачность* (R, G, B, A). Прозрачность тоже от `0.0` (полностью прозрачный) до `1.0` (полностью непрозрачный).
    *    Например:
        *   `(1.0, 0.0, 0.0, 1.0)` — Красный, полностью непрозрачный.
        *   `(0.0, 1.0, 0.0, 0.5)` — Зелёный, наполовину прозрачный.
        * `(0.0,0.0,1.0,0.0)` - Синий полностью прозрачный.

**Пример создания коробочек для цветов:**

```glsl
vec3 myRedColor = vec3(1.0, 0.0, 0.0); // Создали красный цвет.
vec4 myHalfTransparentBlue = vec4(0.0, 0.0, 1.0, 0.5); // Создали наполовину прозрачный синий.
```

### 5.2 Как Смешивать Цвета?

Смешивать цвета в GLSL очень просто! Мы можем использовать волшебные знаки (операторы), которые мы уже знаем из предыдущего раздела, например `+`, `*`.

**Примеры:**

```glsl
vec3 red = vec3(1.0, 0.0, 0.0);
vec3 green = vec3(0.0, 1.0, 0.0);

vec3 yellow = red + green; // Смешали красный и зелёный, получился желтый.
vec3 halfRed = red*0.5; //Сделали красный на половину тусклее.
```

### 5.3 Что Такое Прозрачность?

Когда мы используем `vec4`, у нас появляется четвёртое число — **альфа-канал** (A). Он отвечает за прозрачность:

*   `0.0` — Полностью прозрачный (как будто цвета нет).
*   `1.0` — Полностью непрозрачный (обычный цвет).
*   Что-то между `0.0` и `1.0` — Полупрозрачный.

```glsl
vec4 halfTransparent = vec4(1.0,0.0,0.0,0.5); //Красный полупрозрачный цвет.
vec4 notVisible = vec4(0.0,1.0,0.0,0.0); //Зеленый полностью прозрачный.
```

### 5.4 Итог

Теперь ты знаешь, как создавать, смешивать и изменять цвета в GLSL! Ты можешь создавать все оттенки радуги и даже управлять прозрачностью! Это очень круто!


## Раздел 6: Настоящая Магия! Подводим Итоги и Учимся Творить Сложные Заклинания

Поздравляю, юный волшебник! Ты дошёл до самого интересного раздела нашего справочника! Теперь ты знаешь все базовые заклинания GLSL: переменные, типы данных, функции, процедуры, главную машину `main`, операторы, условия, циклы и цвета! Пришло время объединить все эти знания и научиться творить настоящую графическую магию!

### 6.1 Подводим Итоги: Что Мы Узнали?

Давай ещё раз вспомним, что мы уже умеем:

*   **Коробочки (переменные):** Мы научились создавать коробочки, чтобы хранить в них числа, цвета, и другие данные.
*   **Типы данных:** Теперь мы знаем, какие бывают "вещи" для хранения (`int`, `float`, `bool`, `vec2`, `vec3`, `vec4`, `ivec`).
*   **Машины (функции и процедуры):** Мы научились создавать волшебные машины, которые что-то делают (складывают, умножают, рисуют).
*   **Параметры:** Мы знаем, как передавать этим машинам нужные данные.
*   **Главная машина `main`:**  Мы знаем, что с неё всё начинается.
*   **Волшебные знаки (операторы):** Мы научились использовать знаки `+`, `-`, `*`, `/`, `=`, `>`, `<`, `&&`, `||` и многие другие.
*   **Условия:** Мы умеем использовать `if`, `else if`, `else`, чтобы код выполнялся только при определённых условиях.
* **Циклы**: Научились создавать циклы, что бы повторять код несколько раз.
*   **Цвета:** Мы научились создавать, смешивать и менять цвета.
*   **Фигурные скобки {}:** Помним что это границы.

### 6.2 Сложные Заклинания: Заполнение Массива в Цикле.

Теперь давай попробуем сделать что-то посложнее. Например, представим, что нам нужно создать массив из 10 цветов, где каждый цвет будет ярче предыдущего.  Как это сделать?  Использовать цикл!

```glsl
void main() {
    vec3 rainbow[10]; // Создали рюкзак на 10 цветов
    float increase = 0.1; // На сколько увеличивать яркость
    float start = 0.0;
    for (int i = 0; i < 10; i++) { // Повторяем 10 раз
        rainbow[i] = vec3(start, 0.0, 0.0); // Создаём красный цвет и кладём в рюкзак
        start += increase; // Увеличиваем значение для цвета на 0.1
    }
    //Теперь в нашем рюкзаке 10 красных цветов. от 0.0 до 0.9 яркости.
}
```

**Объяснение:**

1.  `vec3 rainbow[10];` - Создаём "рюкзак" с именем `rainbow`, в который можно положить 10 цветов.
2. `float increase = 0.1;` - переменная на сколько будем увеличивать цвет.
3. `float start = 0.0;` - начальное значение.
3.  `for (int i = 0; i < 10; i++)`: Начинаем цикл, который повторится 10 раз.
    *   `int i = 0;`: Создаём коробочку `i` и кладём в неё `0`. Это наш счётчик.
    *   `i < 10`: Повторяем, пока `i` меньше `10`.
    *   `i++`: В конце каждого повторения увеличиваем `i` на 1.
4.  `rainbow[i] = vec3(start, 0.0, 0.0);`: Помещаем в рюкзак `rainbow` красный цвет, который зависит от значения `start`.
5. `start += increase`: увеличиваем значение `start` на `increase`.

### 6.3 Ещё Одна Магия: Рекурсия

Рекурсия — это когда машина вызывает саму себя! Это как бесконечное отражение в зеркалах. С помощью рекурсии можно делать очень красивые и сложные вещи.

**Пример:**
Давайте попробуем сделать машину которая считает факториал.

```glsl
int factorial(int n) {
    if (n <= 1) { // Если число равно 1 или меньше, возвращаем 1.
        return 1;
    } else { // Иначе, вызываем эту же машину, но с числом n-1.
        return n * factorial(n - 1);
    }
}

void main(){
    factorial(5);// в этом случае получим 120.
}
```

**Объяснение:**

1.  `int factorial(int n)`: Наша машина `factorial` принимает число `n` и возвращает целое число (`int`).
2.  `if (n <= 1)`: Если число `n` меньше или равно `1`, то факториал равен `1`. Мы просто отдаём `1`.
3. `return 1`: Возвращаем значение 1.
4. `else`: Если число `n` больше `1`, то факториал — это `n` умноженное на факториал от `n-1`.
5.  `return n * factorial(n - 1)`: Это самое интересное! Здесь машина `factorial` вызывает *саму себя*, но с числом `n - 1`. Так продолжается, пока `n` не станет меньше или равно `1`.
6. `void main()`: В главной машине вызываем нашу функцию, что бы посчитать факториал числа 5.

**Как это работает**:

* **factorial(5)** вычисляет как **5** * factorial(4).
* **factorial(4)** вычисляет как **4** * factorial(3).
* **factorial(3)** вычисляет как **3** * factorial(2).
* **factorial(2)** вычисляет как **2** * factorial(1).
* **factorial(1)** возвращает **1**.
* И так далее... в итоге мы получаем **120**.

### 6.4 Кодстайл: Как Писать Красивые Заклинания

Когда мы пишем код, важно, чтобы он был не только рабочим, но и красивым, и понятным. Для этого есть **кодстайл** — правила, как писать код. Вот несколько простых правил:

*   **Имена:** Давай всем переменным, функциям и процедурам понятные имена! Вместо `a`, `b`, `c` лучше писать `playerSpeed`, `enemyColor`, `numberOfStars`.
*   **Пробелы:** Используй пробелы, чтобы разделить части кода. Так его легче читать.
*   **Отступы:** Используй отступы, чтобы показать, что относится к телу функции, циклу или условию. В GLSL это обычно 4 пробела или один «таб» (нажатие клавиши Tab).
*   **Комментарии:** Пиши комментарии, чтобы объяснять, что делает твой код. Это поможет тебе и другим разобраться в твоей магии. Комментарии начинаются с `//`
```glsl
//Это комментарий.
```
* **Порядок**: Старайся писать код так, что бы сначала были переменные, потом функции, а в самом конце главная функция.
* **Ясность**: Чем понятнее написан код, тем лучше.

### 6.5 Что Дальше?

Поздравляю! Ты овладел множеством волшебных заклинаний GLSL! Но это только начало! Впереди тебя ждёт ещё много интересного и неизведанного.

```glsl
void main(){
    //Твори свою магию
}
```

В этом справочнике ты узнал всё самое важное для того что бы начать!


## Раздел 6: Настоящая Магия! Подводим Итоги и Учимся Творить Сложные Заклинания !!!!!!!!!!!!!!!!!

Поздравляю, юный волшебник! Ты дошёл до самого интересного раздела нашего справочника! Теперь ты знаешь все базовые заклинания GLSL: переменные, типы данных, функции, процедуры, главную машину `main`, операторы, условия, циклы и цвета! Пришло время объединить все эти знания и научиться творить настоящую графическую магию!

### 6.1 Подводим Итоги: Что Мы Узнали?

Давай ещё раз вспомним, что мы уже умеем:

*   **Коробочки (переменные):** Мы научились создавать коробочки, чтобы хранить в них числа, цвета, и другие данные.
*   **Типы данных:** Теперь мы знаем, какие бывают "вещи" для хранения (`int`, `float`, `bool`, `vec2`, `vec3`, `vec4`, `ivec`).
*   **Машины (функции и процедуры):** Мы научились создавать волшебные машины, которые что-то делают (складывают, умножают, рисуют).
*   **Параметры:** Мы знаем, как передавать этим машинам нужные данные.
*   **Главная машина `main`:**  Мы знаем, что с неё всё начинается.
*   **Волшебные знаки (операторы):** Мы научились использовать знаки `+`, `-`, `*`, `/`, `=`, `>`, `<`, `&&`, `||` и многие другие.
*   **Условия:** Мы умеем использовать `if`, `else if`, `else`, чтобы код выполнялся только при определённых условиях.
* **Циклы**: Научились создавать циклы, что бы повторять код несколько раз.
*   **Цвета:** Мы научились создавать, смешивать и менять цвета.
*   **Фигурные скобки {}:** Помним что это границы.

### 6.2 Сложные Заклинания: Заполнение Массива в Цикле

Теперь давай попробуем сделать что-то посложнее. Например, представим, что нам нужно создать массив из 10 цветов, где каждый цвет будет ярче предыдущего.  Как это сделать?  Использовать цикл!

(```glsl)
void main() {
    vec3 rainbow[10]; // Создали рюкзак на 10 цветов
    float increase = 0.1; // На сколько увеличивать яркость
    float start = 0.0;
    for (int i = 0; i < 10; i++) { // Повторяем 10 раз
        rainbow[i] = vec3(start, 0.0, 0.0); // Создаём красный цвет и кладём в рюкзак
        start += increase; // Увеличиваем значение для цвета на 0.1
    }
    //Теперь в нашем рюкзаке 10 красных цветов. от 0.0 до 0.9 яркости.
}
(```)

**Объяснение:**

1.  `vec3 rainbow[10];` - Создаём "рюкзак" с именем `rainbow`, в который можно положить 10 цветов.
2. `float increase = 0.1;` - переменная на сколько будем увеличивать цвет.
3. `float start = 0.0;` - начальное значение.
3.  `for (int i = 0; i < 10; i++)`: Начинаем цикл, который повторится 10 раз.
    *   `int i = 0;`: Создаём коробочку `i` и кладём в неё `0`. Это наш счётчик.
    *   `i < 10`: Повторяем, пока `i` меньше `10`.
    *   `i++`: В конце каждого повторения увеличиваем `i` на 1.
4.  `rainbow[i] = vec3(start, 0.0, 0.0);`: Помещаем в рюкзак `rainbow` красный цвет, который зависит от значения `start`.
5. `start += increase`: увеличиваем значение `start` на `increase`.

### 6.3 Ещё Одна Магия: Рекурсия

Рекурсия — это когда машина вызывает саму себя! Это как бесконечное отражение в зеркалах. С помощью рекурсии можно делать очень красивые и сложные вещи.

**Пример:**
Давайте попробуем сделать машину которая считает факториал.

(```glsl)
int factorial(int n) {
    if (n <= 1) { // Если число равно 1 или меньше, возвращаем 1.
        return 1;
    } else { // Иначе, вызываем эту же машину, но с числом n-1.
        return n * factorial(n - 1);
    }
}

void main(){
    factorial(5);// в этом случае получим 120.
}
(```)

**Объяснение:**

1.  `int factorial(int n)`: Наша машина `factorial` принимает число `n` и возвращает целое число (`int`).
2.  `if (n <= 1)`: Если число `n` меньше или равно `1`, то факториал равен `1`. Мы просто отдаём `1`.
3. `return 1`: Возвращаем значение 1.
4. `else`: Если число `n` больше `1`, то факториал — это `n` умноженное на факториал от `n-1`.
5.  `return n * factorial(n - 1)`: Это самое интересное! Здесь машина `factorial` вызывает *саму себя*, но с числом `n - 1`. Так продолжается, пока `n` не станет меньше или равно `1`.
6. `void main()`: В главной машине вызываем нашу функцию, что бы посчитать факториал числа 5.

**Как это работает**:

* **factorial(5)** вычисляет как **5** * factorial(4).
* **factorial(4)** вычисляет как **4** * factorial(3).
* **factorial(3)** вычисляет как **3** * factorial(2).
* **factorial(2)** вычисляет как **2** * factorial(1).
* **factorial(1)** возвращает **1**.
* И так далее... в итоге мы получаем **120**.

### 6.4 Кодстайл: Как Писать Красивые Заклинания

Когда мы пишем код, важно, чтобы он был не только рабочим, но и красивым, и понятным. Для этого есть **кодстайл** — правила, как писать код. Вот несколько простых правил:

*   **Имена:** Давай всем переменным, функциям и процедурам понятные имена! Вместо `a`, `b`, `c` лучше писать `playerSpeed`, `enemyColor`, `numberOfStars`.
*   **Пробелы:** Используй пробелы, чтобы разделить части кода. Так его легче читать.
*   **Отступы:** Используй отступы, чтобы показать, что относится к телу функции, циклу или условию. В GLSL это обычно 4 пробела или один «таб» (нажатие клавиши Tab).
*   **Комментарии:** Пиши комментарии, чтобы объяснять, что делает твой код. Это поможет тебе и другим разобраться в твоей магии. Комментарии начинаются с `//`
(```glsl)
//Это комментарий.
(```)
* **Порядок**: Старайся писать код так, что бы сначала были переменные, потом функции, а в самом конце главная функция.
* **Ясность**: Чем понятнее написан код, тем лучше.

### 6.5 Что Дальше?

Поздравляю! Ты овладел множеством волшебных заклинаний GLSL! Но это только начало! Впереди тебя ждёт ещё много интересного и неизведанного.

(```glsl)
void main(){
    //Твори свою магию
}
(```)

В этом справочнике ты узнал всё самое важное для того что бы начать!
