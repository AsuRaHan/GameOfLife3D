# Справочник Разработчика GLSL

## 1. Введение

GLSL (OpenGL Shading Language) — это язык программирования высокого уровня, предназначенный для написания шейдеров в графическом API OpenGL. Шейдеры представляют собой небольшие программы, которые выполняются на графическом процессоре (GPU) и отвечают за визуализацию графических объектов.

### 1.1 Что такое GLSL?

GLSL — это C-подобный язык, который позволяет разработчикам управлять процессом растеризации, освещения, затенения и другими эффектами, реализуемыми на GPU. Он предоставляет широкие возможности для управления цветом, текстурами, геометрией и другими аспектами рендеринга.

### 1.2 Для чего используется GLSL?

GLSL используется для написания шейдеров, которые определяют, как будут выглядеть объекты в сцене. Шейдеры позволяют:

*   **Изменять геометрию объектов:**  С помощью vertex shaders можно трансформировать вершины объектов, перемещать их, вращать, масштабировать.
*   **Изменять цвета объектов:** С помощью fragment shaders можно устанавливать цвет каждого фрагмента (пикселя), учитывать освещение, затенение, текстурирование.
*   **Создавать сложные визуальные эффекты:**  Шейдеры позволяют реализовывать практически любые визуальные эффекты, от простых градиентов до сложных алгоритмов освещения, затенения, отражения, преломления и т.д.
* **Работать с вычислениями:** compute shaders позволяют проводить вычисления параллельно на GPU.

### 1.3 Взаимодействие с OpenGL

GLSL не существует сам по себе. Он работает в связке с графическим API OpenGL. OpenGL — это набор функций и констант, которые позволяют управлять GPU. GLSL используется для написания шейдеров, а OpenGL — для загрузки, компиляции и линковки этих шейдеров, а также для передачи им данных и управления их выполнением.

Шейдеры, написанные на GLSL, должны быть скомпилированы и привязаны к OpenGL-программе, чтобы GPU мог их выполнить.

### 1.4 Типы Шейдеров

В OpenGL существует несколько типов шейдеров, каждый из которых выполняет свою определённую роль в графическом конвейере:

*   **Vertex Shader (Вершинный Шейдер):**
    *   Выполняется для каждой вершины объекта.
    *   Отвечает за трансформацию вершин (перемещение, вращение, масштабирование).
    *   Может изменять такие атрибуты вершин, как положение, цвет, текстурные координаты.
    *   Должен вычислять координаты вершины в пространстве отсечения.
*   **Tessellation Control Shader (Шейдер Тесселяции Управления)**
    * Выполняется после вершинного шейдера.
    * Отвечает за управление тесселяцией, то есть разбиением примитивов на более мелкие.
* **Tessellation Evaluation Shader (Шейдер Оценки Тесселяции)**
    * Выполняется после шейдера тесселяции управления.
    * Отвечает за вычисление координат новых вершин после тесселяции.
*   **Geometry Shader (Геометрический Шейдер):**
    *   Выполняется после вершинного шейдера или тесселяции.
    *   Обрабатывает целые примитивы (точки, линии, треугольники).
    *   Может создавать новые примитивы или удалять существующие.
*   **Fragment Shader (Фрагментный Шейдер):**
    *   Выполняется для каждого фрагмента (пикселя).
    *   Отвечает за вычисление цвета фрагмента.
    *   Может учитывать освещение, текстуры, затенение и другие эффекты.
*  **Compute Shader (Шейдер Вычислений):**
   * Шейдеры которые используются для вычислений.
   * Выполняются на GPU
   * Позволяют выполнять операции параллельно.

Каждый тип шейдера имеет свои входные и выходные данные, которые могут быть связаны с другими этапами конвейера.

**Что дальше?**
В следующих разделах ты узнаешь: про структуру GLSL кода, про переменные и типы данных, про операторы, про управляющие конструкции, про функции и многое другое.

## 2. Структура GLSL-кода

GLSL-код, как и любой код на другом языке программирования, имеет свою определённую структуру. В этом разделе мы рассмотрим основные элементы, из которых состоит GLSL-программа.

### 2.1 Версия GLSL (`#version`)

Каждый GLSL-код начинается с директивы `#version`, которая указывает версию языка. Это необходимо для того, чтобы компилятор мог правильно интерпретировать код.

```glsl
#version 450 core
```

*   `#version`:  Это препроцессорная директива, указывающая версию GLSL.
*   `450`:  Это номер версии. В данном случае используется GLSL 4.50.
* `core`: Указывает что используется core профиль. В этом случае удалены устаревшие возможности языка.
* **Важно**: Директива `#version` должна быть в самом начале кода, до любых других директив или объявлений.

### 2.2 Препроцессорные Директивы

Перед тем, как код GLSL будет скомпилирован, он проходит через препроцессор. Препроцессор обрабатывает специальные команды, которые начинаются с `#`.  Вот основные из них:

*   **`#define`:**  Определяет константу или макрос.
    ```glsl
    #define MAX_LIGHTS 8
    #define PI 3.14159
    #define SQR(x) ((x) * (x)) // Макрос для возведения в квадрат
    ```
*   **`#undef`:** Отменяет определение константы или макроса.
    ```glsl
    #undef MAX_LIGHTS
    ```
*   **`#if`, `#elif`, `#else`, `#endif`:** Используются для условной компиляции кода.
    ```glsl
    #if defined(USE_SHADOWS)
    // Код для отрисовки теней.
    #elif defined(USE_FOG)
    // Код для тумана.
    #else
    // Код для отрисовки без доп. эффектов.
    #endif
    ```
*   **`#ifdef`, `#ifndef`:** Проверяют, определена ли константа.
     ```glsl
    #ifdef USE_TEXTURE
    // Код для текстур.
    #endif
    ```
*   **`#error`, `#warning`:** Генерируют ошибки или предупреждения во время компиляции.
     ```glsl
    #error My error message.
    #warning My warning message.
    ```
*   **`#include`:**  Подключает содержимое другого файла.
    ```glsl
    #include "my_utils.glsl"
    ```
*   **`#extension`:**  Включает или отключает расширения GLSL.
    ```glsl
    #extension GL_ARB_separate_shader_objects : enable
    ```

### 2.3 Квалификаторы

Квалификаторы — это специальные ключевые слова, которые изменяют поведение переменных, определяя их тип доступа, область видимости, способ хранения или другие свойства. Квалификаторы указываются *перед* типом переменной. Вот основные из них:

*   **`const`:**  Константа. Значение не может быть изменено после инициализации. Константы обычно используются для определения значений, которые не должны меняться в процессе выполнения шейдера.

```glsl
    const float PI = 3.14159;
    const int MAX_LIGHTS = 8;
```


*   **`in`:** Входная переменная. Используется для передачи данных *в* шейдер извне (от OpenGL). Квалификатор `in` указывает, что значение переменной будет передано в шейдер перед его выполнением. В разных типах шейдеров могут быть разные входные переменные.

```glsl
in vec3 position; // Позиция вершины.
in vec2 texCoord; // Текстурные координаты.
in vec3 normal; // Нормаль к поверхности.
```

*   **`out`:** Выходная переменная. Используется для передачи данных *из* шейдера наружу (в OpenGL). В разных типах шейдеров могут быть разные выходные переменные. Например, во фрагментном шейдере выходная переменная обычно используется для указания цвета фрагмента.

```glsl
out vec4 fragColor;
```

*   **`uniform`:** Переменная, значение которой одинаково для всех вызовов данного шейдера в течение одного рендерингового вызова (одного кадра). `uniform` переменные обычно используются для передачи параметров сцены (матриц, параметров света, текстур) из C++ кода в шейдер.

```glsl
uniform mat4 modelViewProjectionMatrix; // Матрица преобразования.
uniform vec3 lightDirection; // Направление света.
uniform sampler2D myTexture;// Семплер для текстуры.
```

**Важно**: uniform переменные не могут быть изменены внутри шейдера.

*   **`layout`:** Квалификатор `layout` — это мощный инструмент для указания дополнительной информации о переменных. Он используется для задания различных настроек, а именно:

*   **`location`:** Указывает *номер слота* для входной переменной. Входные данные, передаваемые из C++ кода в вершинный шейдер, поступают в виде потока данных, где каждой переменной соответствует свой слот. Если в C++ коде не будет указано, в какой слот какую переменную класть, то GLSL сделает это самостоятельно. Если мы хотим задать положение самостоятельно, то можем использовать `layout`.

```glsl
layout (location = 0) in vec3 position; // Позиция будет в слоте 0.
layout (location = 1) in vec3 normal;   // Нормаль будет в слоте 1.
layout (location = 2) in vec2 texCoord; // Текстурная координата будет в слоте 2.
```

* **Важно**: Нумерация слотов начинается с `0`.

*   **`binding`:** Указывает, к какому блоку данных (uniform buffer object) привязана переменная или блок.

```glsl
layout (std140, binding = 0) uniform TransformBlock {
    mat4 model;
    mat4 view;
    mat4 projection;
};
    layout (binding = 1) uniform sampler2D myTexture;//указываем к какому блоку привязать семплер.
```

* **`std140`**: Это стандартное выравнивание, которое нужно для блоков.
*  `TransformBlock` — это пример `uniform` блока. Это способ группировать однотипные `uniform` переменные.
* **`std140`, `std430`** и другие: Указывает на выравнивание данных. Данные квалификаторы используют когда объявляют блоки данных.
    *  `std140`: Самый распространённый вариант. Гарантирует переносимость между разными реализациями GLSL.
    *  `std430`: Похож на `std140` но он более новый.
    * `shared`: Используется только в блоках `shared`.
* **`shared`**: Данный квалификатор используется только для блоков. Он используется что бы использовать память совместно несколькими шейдерами.

```glsl
layout(local_size_x = 16, local_size_y = 16) in; //размер рабочей группы.
layout(shared) uniform MyBlock{
    int myData[];
}; // блок данных который будет использоваться совместно между всеми группами.
```

*   **Зачем это нужно?**  Квалификатор `layout` даёт нам больше контроля над тем, как данные передаются между C++ и GLSL. Он полезен в нескольких случаях:
    *   Совместимость с C++ кодом:  Если ты хочешь, чтобы данные из C++ кода точно соответствовали данным в шейдере.
    *   Оптимизация: Иногда правильное расположение данных может улучшить производительность.
    * Для работы с UBO и SSBO.
    
* **Важно**: Квалификатор layout не предназначен для изменения значений переменной. Он используется только для указания информации о переменной.

**В итоге:**

Квалификаторы — это мощный инструмент, который позволяет точно контролировать поведение переменных в GLSL. Правильное использование квалификаторов — залог эффективного и правильного выполнения шейдера.

### 2.4 Входные и Выходные Данные

Шейдеры взаимодействуют с внешним миром (например, с C++ кодом, который управляет OpenGl с помощью входных и выходных данных. Эти данные позволяют передавать информацию в шейдер и получать результаты его работы.

#### 2.4.1 Входные Данные `in`

Входные данные передаются *в* шейдер извне, обычно из C++ кода через API OpenGL. Они объявляются с квалификатором `in`. В разных типах шейдеров могут быть разные входные переменные:

*   **Vertex Shader (Вершинный Шейдер):** В вершинный шейдер передаются данные для каждой вершины, такие как:
    *   **Позиция:** Координаты вершины в пространстве объекта или в мировом пространстве.
    *   **Нормаль:** Вектор, перпендикулярный поверхности в данной вершине. Используется для вычисления освещения.
    *   **Текстурные координаты:** Координаты, которые используются для наложения текстур.
    *   **Цвет:** Цвет вершины.
    * **И другое**: Так же можно передать и другие переменные.

    ```glsl
    // Пример входных данных в вершинном шейдере:
    layout (location = 0) in vec3 position; // Позиция вершины.
    layout (location = 1) in vec3 normal;   // Нормаль к поверхности.
    layout (location = 2) in vec2 texCoord; // Текстурная координата.
    layout (location = 3) in vec4 color; // Цвет вершины.
    ```

*   **Fragment Shader (Фрагментный Шейдер):** Во фрагментный шейдер передаются данные, интерполированные из данных вершинного шейдера:
    * **Координаты**: Координаты фрагмента.
    *  **Цвета**: Цвета полученные из вершинного шейдера.
    *  **Текстурные координаты**: Текстурные координаты полученные из вершинного шейдера.
    *   И тд.
    ```glsl
        // Пример входных данных во фрагментном шейдере:
        in vec3 interpolatedColor; // Цвет интерполированный из вершинного шейдера.
        in vec2 interpolatedTexCoord; // Текстурные координаты интерполированные из вершинного шейдера.
    ```

*   **Geometry Shader (Геометрический Шейдер):** В геометрический шейдер передаются данные для всего примитива (вершина, линия или треугольник).
    ```glsl
        // Пример входных данных в геометрическом шейдере:
        layout (triangles) in;
        in vec3 normal[]; // массив нормалей для каждого угла треугольника.
    ```
* **Tessellation Control Shader и Tessellation Evaluation Shader**:
     *В данных шейдерах передаются данные для каждой вершины.

*   **Compute Shader (Шейдер Вычислений):** В compute шейдер, обычно, не передаются данные о вершинах. Он обычно использует блоки памяти и `uniform` переменные для выполнения своей задачи.

**Как передавать данные из C++ кода?**

Для передачи данных в вершинный шейдер из C++ используются:

*   **Вершинные атрибуты:** Данные для каждой вершины, такие как позиция, цвет и т.д.
*   **Uniform-переменные:** Данные, общие для всех вершин, например, матрицы преобразования.

Для передачи данных в фрагментный шейдер из C++ используются:

*   **Uniform-переменные:**  например, текстурные семплеры.

### 2.4.2 Выходные Данные `out`

Выходные данные передаются *из* шейдера наружу. Каждому типу шейдеров можно назначить свои выходные данные.
* **Vertex Shader (Вершинный Шейдер)**: Выходные данные вершинного шейдера используются для передачи информации во фрагментный шейдер и к следующим этапам графического конвейера.
     ```glsl
       out vec3 interpolatedColor; // Цвет, который мы будем передавать фрагментному шейдеру.
       out vec2 interpolatedTexCoord; // Текстурные координаты, которые мы будем передавать фрагментному шейдеру.
    ```
*   **Fragment Shader (Фрагментный Шейдер):** Фрагментный шейдер должен в обязательном порядке определять цвет фрагмента.
    ```glsl
    out vec4 fragColor; // Цвет текущего фрагмента (пикселя).
    ```
* **Geometry Shader (Геометрический Шейдер)**: может передавать данные для каждого примитива.
```glsl
    layout(triangle_strip, max_vertices = 3) out;
    out vec4 nextColor;//передаем цвет дальше.
```
*  **Tessellation Control Shader и Tessellation Evaluation Shader**: В них можно передавать новые вершины и их атрибуты.
* **Compute Shader (Шейдер Вычислений)**: В compute шейдеры, не имеют явно определенных входных и выходных данных. В место этого они используют общие блоки памяти, для чтения и записи данных.

### 2.4.3 Итог

В этом разделе мы рассмотрели, как шейдеры обмениваются данными с помощью квалификаторов `in` и `out`.  Понимание того, как шейдеры получают и возвращают данные, является ключевым для создания сложных графических эффектов.



### 2.5 Функция `main`

Функция `main` — это точка входа в шейдерную программу. В ней выполняется весь код. Каждый шейдер должен содержать функцию `main`.

```glsl
void main() {
    // Здесь будет написан код шейдера.
}
```

**Что дальше?**
В следующих разделах мы рассмотрим переменные, типы данных, операторы и много других вещей.

## 3. Переменные и Типы Данных

Переменные в GLSL используются для хранения данных, с которыми оперируют шейдеры.  Каждая переменная имеет свой тип, который определяет, какие данные она может хранить.

### 3.1 Объявление Переменных

Переменная объявляется путём указания её типа и имени:

```glsl
тип имя_переменной;
```

Например:

```glsl
int myAge;
float playerSpeed;
vec3 myColor;
```

При объявлении переменной можно сразу присвоить ей значение:

```glsl
int numberOfLives = 3;
float playerSpeed = 5.5;
vec3 myColor = vec3(1.0, 0.0, 0.0); // Красный цвет
```

### 3.2 Скалярные Типы

Скалярные типы данных хранят одно значение:

*   **`int`:** Целое число.

```glsl
int count = 10; //целое число.
```

*   **`float`:** Дробное число (число с плавающей точкой).

```glsl
float speed = 2.5; // число с плавающей точкой.
```

*   **`bool`:** Логический тип, может принимать значения `true` (истина) или `false` (ложь).

```glsl
 bool isRunning = true; //логический тип.
```

*   **`uint`:** Беззнаковое целое число (может быть только положительным).

```glsl
uint index = 10u;//беззнаковое целое число.
```

### 3.3 Векторы

Векторы — это наборы из нескольких чисел одного типа.

*   **`vec2`:** Вектор из двух чисел с плавающей точкой.

```glsl
vec2 position = vec2(10.0, 20.0); //двойка чисел с плавающей точкой.
```

*   **`vec3`:** Вектор из трёх чисел с плавающей точкой. Часто используется для представления цветов (R, G, B) или координат в 3D-пространстве.

```glsl
vec3 color = vec3(1.0, 0.0, 0.0); //тройка чисел с плавающей точкой.
```

*   **`vec4`:** Вектор из четырёх чисел с плавающей точкой. Часто используется для представления цвета с альфа-каналом (прозрачностью) (R, G, B, A) или координат в 4D-пространстве.

```glsl
vec4 color = vec4(1.0, 0.0, 0.0, 1.0); //четверка чисел с плавающей точкой.
```

*   **`ivec2`, `ivec3`, `ivec4`:** Векторы из двух, трёх или четырёх *целых* чисел.

```glsl
ivec3 position = ivec3(1,2,3);//тройка целых чисел.
```

*   **`bvec2`, `bvec3`, `bvec4`:** Векторы из двух, трёх или четырёх *булевых* значений.

```glsl
bvec2 isTrue = bvec2(true,false);//двойка логических значений.
```

*   **`uvec2`, `uvec3`, `uvec4`:** Векторы из двух, трёх или четырёх *беззнаковых целых* чисел.

```glsl
uvec4 index = uvec4(1u,2u,3u,4u);//четверка беззнаковых чисел.
```

### 3.4 Матрицы

Матрицы используются для описания линейных преобразований (вращение, масштабирование, сдвиг).

*   **`mat2`:** Матрица 2x2.

```glsl
mat2 rotationMatrix;
```

*   **`mat3`:** Матрица 3x3.

```glsl
mat3 normalMatrix;
```

*   **`mat4`:** Матрица 4x4. Чаще всего используется для представления матриц преобразования (модель-вид-проекция).

```glsl
mat4 modelViewProjectionMatrix;
```

### 3.5 Непрозрачные Типы

Непрозрачные типы — это особый вид типов данных, которые используются для работы с внешними ресурсами, такими как текстуры или буферы. В отличие от обычных типов, содержимое непрозрачных типов не может быть напрямую прочитано или изменено внутри шейдера.  Вместо этого, для работы с ними используются специальные встроенные функции.

*   **Семплеры `sampler*`:** Используются для доступа к текстурам. Существуют разные типы семплеров в зависимости от типа текстуры:
    *   `sampler1D`, `sampler2D`, `sampler3D`
    *   `samplerCube`
    *   `sampler1DShadow`, `sampler2DShadow`
    ```glsl
    uniform sampler2D myTexture; // Двумерная текстура.
    uniform samplerCube myCubeTexture; // Кубическая текстура.
    uniform sampler2DShadow myShadowMap; // Текстура тени.
    ```

**Объяснение**:

*   **`uniform`**: Ключевое слово `uniform` говорит о том, что это переменная-параметр.
*   **`sampler2D`, `samplerCube`, `sampler1DShadow`**: Это типы данных. Указывают какого типа будет текстура.
* **Что не можем**: Мы не можем напрямую изменить значение семплера. Мы не можем изменять само изображение.
* **Для чего нужны**: Семплеры используются как аргумент в функции `texture`.
*  **Сложность**: Семплер сам по себе не содержит текстуру. Вместо этого, он содержит ссылку на текстуру, и параметры, необходимые для её получения.
*   **Работа с текстурой**: Для того что бы работать с текстурой, мы должны использовать функцию `texture`.

    ```glsl
        vec4 texColor = texture(myTexture, texCoord);
    ```
* `myTexture`: Это наш семплер.
* `texCoord`: Это координаты для выборки пикселя.
* `texColor`: В эту переменную вернётся цвет.
s

### 3.6 Массивы

Массивы позволяют хранить несколько значений одного типа под одним именем.

```glsl
int numbers[5]; // Массив из 5 целых чисел.
vec3 colors[3]; // Массив из 3 цветов.
```

Доступ к элементам массива осуществляется по индексу (начиная с `0`):

```glsl
numbers[0] = 10; // Запись значения в первый элемент массива.
vec3 myColor = colors[2]; // Чтение значения из третьего элемента массива.
```

### 3.7 Структуры

Структуры позволяют объединять несколько переменных разных типов в одну именованную сущность.

```glsl
struct Light {
    vec3 position;
    vec3 color;
    float intensity;
};

Light myLight; // Теперь у нас есть переменная типа Light.
myLight.position = vec3(1.0, 0.0, 0.0); // Обращение к переменным через точку.
```

### 3.8 `void`

`void` - специальный тип, который используется для обозначения процедур, то есть функций, которые ничего не возвращают.

```glsl
void myProcedure(){
    // ... Тут что то происходит... но ни чего не возвращается.
}
```

### 3.9 Итог

В этом разделе мы познакомились с переменными и основными типами данных, которые используются в GLSL. Знания о типах данных являются фундаментом для дальнейшего изучения языка.

**Что дальше?**

В следующем разделе мы рассмотрим, какие бывают операторы в GLSL.

## 4. Операторы

Операторы в GLSL — это символы, которые выполняют определённые операции над данными (переменными и константами).  Они позволяют производить математические вычисления, логические операции, присваивания и многое другое.

### 4.1 Арифметические Операторы

Арифметические операторы используются для выполнения математических действий:

*   **`+` (Сложение):** Складывает два значения.

    ```glsl
    int sum = 5 + 3; // sum будет равен 8
    float total = price1 + price2;
    ```

*   **`-` (Вычитание):** Вычитает одно значение из другого.

    ```glsl
    int difference = 10 - 4; // difference будет равен 6
    float balance = total - cost;
    ```

*   **`*` (Умножение):** Умножает два значения.

    ```glsl
    int product = 2 * 6; // product будет равен 12
    float area = width * height;
    ```

*   **`/` (Деление):** Делит одно значение на другое.

    ```glsl
    float quotient = 10.0 / 2.0; // quotient будет равен 5.0
    float ratio = value / total;
    ```

*   **`%` (Остаток от деления):** Возвращает остаток от целочисленного деления.

    ```glsl
    int remainder = 10 % 3; // remainder будет равен 1
    int isEven = number % 2; //проверяем делится ли на 2
    ```
*   **`++` (Инкремент):** Увеличивает значение на 1. Может использоваться как префиксный (`++i`) или постфиксный (`i++`) оператор.

    ```glsl
    int i = 5;
    i++; // i теперь равен 6
    ++i; // i теперь равен 7
    ```

*   **`--` (Декремент):** Уменьшает значение на 1. Также может использоваться как префиксный (`--i`) или постфиксный (`i--`) оператор.

    ```glsl
    int j = 10;
    j--; // j теперь равен 9
    --j; // j теперь равен 8
    ```

### 4.2 Операторы Присваивания

Операторы присваивания используются для изменения значения переменной:

*   **`=` (Присваивание):**  Присваивает значение переменной.

    ```glsl
    int count = 0;
    float speed = 2.5;
    vec3 color = vec3(1.0, 0.0, 0.0);
    ```

*   **`+=` (Присваивание с сложением):** Складывает значение переменной с другим значением и присваивает результат обратно переменной.

    ```glsl
    int count = 5;
    count += 3; // count теперь равен 8 (то же самое, что count = count + 3;)
    ```

*   **`-=` (Присваивание с вычитанием):** Вычитает значение из переменной и присваивает результат.

    ```glsl
    float balance = 10.0;
    balance -= 2.5; // balance теперь равен 7.5 (то же самое, что balance = balance - 2.5;)
    ```

*   **`*=` (Присваивание с умножением):** Умножает значение переменной на другое значение и присваивает результат.

    ```glsl
    float scale = 2.0;
    scale *= 3.0; // scale теперь равен 6.0 (то же самое, что scale = scale * 3.0;)
    ```

*   **`/=` (Присваивание с делением):** Делит значение переменной на другое значение и присваивает результат.

    ```glsl
    float ratio = 10.0;
    ratio /= 2.0; // ratio теперь равен 5.0 (то же самое, что ratio = ratio / 2.0;)
    ```

* **`%=`**, **`&=`**, **`|=`**, **`^=`**, **`<<=`**, **`>>=`**: Данные операторы похожи на предыдущие но используют соответственно операции остатка от деления, побитовое `И`, побитовое `ИЛИ`, побитовое `ИСКЛЮЧАЮЩЕЕ ИЛИ`, побитовый сдвиг влево и побитовый сдвиг в право.

### 4.3 Операторы Сравнения

Операторы сравнения сравнивают два значения и возвращают `bool` (истину или ложь):

*   **`==` (Равно):** Проверяет, равны ли два значения.

    ```glsl
    bool isEqual = (5 == 5); // isEqual будет true
    ```

*   **`!=` (Не равно):** Проверяет, не равны ли два значения.

    ```glsl
    bool isNotEqual = (5 != 3); // isNotEqual будет true
    ```

*   **`<` (Меньше):** Проверяет, меньше ли первое значение второго.

    ```glsl
    bool isLess = (2 < 4); // isLess будет true
    ```

*   **`>` (Больше):** Проверяет, больше ли первое значение второго.

    ```glsl
    bool isGreater = (5 > 3); // isGreater будет true
    ```

*   **`<=` (Меньше или равно):** Проверяет, меньше ли первое значение второго или равно ему.

    ```glsl
    bool isLessOrEqual = (3 <= 3); // isLessOrEqual будет true
    ```

*   **`>=` (Больше или равно):** Проверяет, больше ли первое значение второго или равно ему.

    ```glsl
    bool isGreaterOrEqual = (5 >= 5); // isGreaterOrEqual будет true
    ```

### 4.4 Логические Операторы

Логические операторы используются для работы с булевыми значениями:

*   **`&&` (Логическое И):** Возвращает `true`, если оба операнда `true`, иначе `false`.

    ```glsl
    bool bothTrue = (true && true); // bothTrue будет true
    bool oneFalse = (true && false); // oneFalse будет false
    ```

*   **`||` (Логическое ИЛИ):** Возвращает `true`, если хотя бы один операнд `true`, иначе `false`.

    (```glsl)
    bool oneTrue = (true || false); // oneTrue будет true
    bool bothFalse = (false || false); // bothFalse будет false
    ```

*   **`!` (Логическое НЕ):** Инвертирует значение операнда (из `true` делает `false`, из `false` делает `true`).

    ```glsl
    bool isFalse = !true; // isFalse будет false
    bool isTrue = !false; // isTrue будет true
    ```

### 4.5 Тернарный Оператор

Тернарный оператор — это сокращённая запись для условия `if-else`. Он имеет вид:

```glsl
условие ? значение_если_истина : значение_если_ложь;
```

**Пример:**

```glsl
float result = (a > b) ? a : b;
// Если a больше b, то result будет равен a, иначе result будет равен b.
```

### 4.6 Операторы Выборки

Эти операторы позволяют обращаться к элементам векторов и матриц.

* **`(`.) (Обращение к компонентам):** Используется для доступа к компонентам векторов и матриц по именам. Например, для вектора `vec4` можно использовать `x`, `y`, `z`, `w` (для координат), или `r`, `g`, `b`, `a` (для цвета). Для матриц доступ к элементам можно получать через индексы.

```glsl
    vec4 myColor = vec4(0.5, 0.2, 0.8, 1.0);
    float red = myColor.r;//0.5
    float blue = myColor.b;//0.8
    float alpha = myColor.a;//1.0

    mat4 myMatrix;
    float value = myMatrix[0][0]; // Получаем значение из первого ряда первого столбца.
```

* **`[]` (Обращение к элементам):** Используется для доступа к элементам массивов, и так же к вектору и матрице по индексу. Индексация начинается с нуля.

```glsl
    float numbers[3] = float[](1.0,2.0,3.0);
    float myNumber = numbers[0]; //получаем значение 1.0
    vec3 myVec = vec3(0.0,0.5,1.0);
    float value = myVec[0];//получаем значение 0.0

    mat4 myMatrix;
    vec4 myVec4 = myMatrix[0]; //Получаем первый столбец матрицы.
```

### 4.7 Итог
Теперь ты знаком с основными операторами в GLSL! Зная их ты можешь делать в шейдерах практически всё!

**Что дальше?**

В следующем разделе мы рассмотрим, какие бывают управляющие конструкции.

## 5. Управляющие Конструкции

Управляющие конструкции в GLSL позволяют изменять порядок выполнения кода в зависимости от условий или повторять определённый блок кода несколько раз. В этом разделе мы рассмотрим основные управляющие конструкции.

### 5.1 Условия (`if`, `else if`, `else`)

Условия позволяют выполнять код только в том случае, если выполняется определённое условие.

*   **`if`:**  Выполняет код, если условие истинно (`true`).

    ```glsl
    if (playerHealth > 0) {
        // Игрок жив, выполняем код.
    }
    ```

*   **`else if`:** Проверяет дополнительное условие, если предыдущее условие `if` было ложным (`false`).

    ```glsl
    if (temperature > 30.0) {
        // Температура высокая.
    } else if (temperature < 10.0) {
        // Температура низкая.
    }
    ```

*   **`else`:** Выполняет код, если все предыдущие условия были ложными.

    ```glsl
     if (playerHealth > 0) {
        // Игрок жив.
    } else {
        // Игрок умер.
    }
    ```

**Пример с `if`, `else if` и `else`:**

```glsl
    float distance = length(playerPosition - enemyPosition); // Считаем растояние между игроком и врагом.

    if (distance < 1.0) {
        // Близко, атакуем.
    } else if (distance < 5.0) {
       //Среднее расстояние, бежим.
    } else {
        // Далеко, ничего не делаем.
    }
```

### 5.2 Циклы (`for`, `while`, `do-while`)

Циклы позволяют повторять выполнение блока кода несколько раз.

*   **`for`:** Используется, когда известно количество повторений или когда есть счётчик.
    
    ```glsl
    for (int i = 0; i < 10; i++) {
        // Код, который нужно повторить 10 раз.
    }
    ```

    **Объяснение:**
    * `int i = 0`: создаём переменную счётчик i и задаём её стартовое значение 0.
    * `i < 10`: условие, пока i меньше 10 цикл повторяется.
    * `i++`: Каждый раз, после выполнения кода в теле цикла, к переменной i прибавляем 1.

*   **`while`:** Используется, когда количество повторений заранее неизвестно, а есть какое-то условие. Цикл выполняется, пока условие истинно.

```glsl
    while(energy > 0){
        // Код, который будет повторяться пока energy больше 0.
       energy -= 0.1;
    }
```

*   **`do-while`:** Похож на `while`, но тело цикла выполняется *как минимум один раз*. Условие проверяется *после* выполнения кода.

```glsl
    int count = 0;
    do{
       // Код который выполняется один раз.
       count++;
    } while(count < 10);//После чего проверяем условие.
```

### 5.3 Управление Потоком (`break`, `continue`, `return`, `discard`)

Эти операторы позволяют изменять стандартный порядок выполнения кода в циклах и функциях.

*   **`break`:**  Досрочно прерывает выполнение цикла.

    ```glsl
    for (int i = 0; i < 100; i++) {
        if (foundTarget) {
            break; // Выходим из цикла, если цель найдена.
        }
    }
    ```

*   **`continue`:**  Переходит к следующей итерации цикла, пропуская оставшуюся часть кода в текущей итерации.

    ```glsl
    for (int i = 0; i < 10; i++) {
       if(i%2 == 0){
            continue; // Если число четное переходим к следующему циклу.
       }
        // Код который выполняется только с нечётными числами
    }
    ```

*   **`return`:**  Выходит из текущей функции и может возвращать значение.
    
    ```glsl
    float add(float a, float b){
        return a + b; // возвращаем сумму двух чисел.
    }
    ```

*   **`discard`:**  Используется только во фрагментном шейдере.  Прерывает обработку текущего фрагмента и "отбрасывает" его.

    ```glsl
    if(myColor.a < 0.5){
    discard;// если фрагмент на половину прозрачный, то мы его удаляем.
    }
    ```

    **Важно**: Данный оператор работает только во фрагментном шейдере.

### 5.4 Итог

В этом разделе мы рассмотрели управляющие конструкции, которые позволяют делать код в GLSL гибким и динамичным. Теперь ты знаешь как управлять выполнением кода с помощью условий, циклов и операторов управления потоком.

**Что дальше?**

В следующем разделе мы поговорим о том, что такое функции, как их создавать и использовать в GLSL.

## 6. Функции

Функции в GLSL — это именованные блоки кода, которые выполняют определённую задачу. Они помогают структурировать код, делать его более читаемым и повторно использовать одни и те же фрагменты кода.

### 6.1 Объявление Функции

Функция объявляется с указанием типа возвращаемого значения, имени функции и списка параметров (если они есть) в скобках.

```glsl
тип_возвращаемого_значения имя_функции(тип_параметра1 имя_параметра1, тип_параметра2 имя_параметра2, ... ) {
    // Тело функции: код, который выполняется при вызове функции.
    // ...
    return возвращаемое_значение; //если функция не void то нужно вернуть значение
}
```

**Пример:**

```glsl
float add(float a, float b) {
    float sum = a + b;
    return sum;
}
```

**Объяснение:**

*   **`float`:** Тип возвращаемого значения. Эта функция возвращает дробное число.
*   **`add`:** Имя функции.
*   **`(float a, float b)`:** Список параметров. В скобках указаны типы и имена параметров, которые принимает функция. В данном случае, функция принимает два дробных числа `a` и `b`.
*   **`{ ... }`:** Фигурные скобки ограничивают тело функции, то есть код, который выполняется при вызове этой функции.
*   **`return sum;`:** Оператор `return` завершает выполнение функции и возвращает значение переменной `sum`.

**Функции без возвращаемого значения (процедуры):**

Если функция не должна ничего возвращать, используется тип `void`:

```glsl
void printMessage(string message){ // процедура
   //... Что то происходит. но ни чего не возвращается.
}
```

### 6.2 Вызов Функции

Чтобы выполнить код в теле функции, её нужно вызвать по имени и передать ей нужные параметры (если они есть).

```glsl
float result = add(5.0, 3.0); // Вызываем функцию add и передаём ей значения 5.0 и 3.0.
```

### 6.3 Параметры Функций

Параметры — это данные, которые передаются в функцию при её вызове.

*   **Входные параметры:** Передаются извне в функцию.
*   **Внутри функции:** Параметры доступны как переменные.
*   **Типы:** Тип каждого параметра нужно указывать при объявлении функции.

    ```glsl
    float calculateArea(float width, float height){
    // width и height это параметры.
    return width * height;
    }
    ```

### 6.4 Возвращаемые Значения

Функции могут возвращать значения с помощью оператора `return`. Тип возвращаемого значения должен быть указан в объявлении функции. Если функция ничего не возвращает то надо использовать `void`.

```glsl
    float add(float a, float b) {
        return a + b; // Возвращаем сумму a и b.
    }

    void printMessage(string message){
        // ... ничего не возвращаем.
        return; // в данном случае можно опустить этот оператор.
    }
```

### 6.5 Область Видимости

Переменные объявленные внутри функции видны только в ней.

```glsl
float myFunction(){
   int myVar; // myVar видна только внутри этой функции.
}
```

Переменные объявленные вне функций доступны везде.

```glsl
float myVar;// myVar видна везде.

float myFunction(){
   // myVar доступна тут.
}
```

### 6.6 Рекурсия

Функция может вызывать саму себя. Это называется **рекурсией**. Рекурсия используется для решения задач, которые можно разбить на более мелкие, похожие подзадачи.

**Пример: факториал**

```glsl
int factorial(int n) {
    if (n <= 1) {
        return 1; // Базовый случай: факториал 1 равен 1.
    } else {
        return n * factorial(n - 1); // Рекурсивный вызов.
    }
}
```

### 6.7 Функция `main`

Как мы уже знаем, функция `main` — это главная функция, с которой начинается выполнение шейдерной программы. Она не принимает никаких параметров и не возвращает никакого значения (тип `void`).

```glsl
void main() {
    // ... Тут происходит всё самое важное ...
}
```

### 6.8 Итог

Теперь ты знаешь всё про функции! Ты знаешь, как их объявлять, вызывать, передавать им параметры и возвращать значения. Ты также узнал, что такое рекурсия и как она работает. Функции — это очень мощный инструмент, который поможет тебе сделать твой GLSL-код более организованным и читаемым!

**Что дальше?**

В следующем разделе мы рассмотрим встроенные функции GLSL, которые очень часто используются для графических вычислений.

## 7. Встроенные Функции

GLSL предоставляет множество встроенных функций, которые значительно упрощают разработку шейдеров.  Эти функции оптимизированы для работы на GPU и охватывают широкий спектр математических, геометрических и других операций. В этом разделе мы рассмотрим наиболее часто используемые из них.

### 7.1 Математические Функции

*   **`abs(x)`:** Возвращает абсолютное значение `x`.
    ```glsl
    float absoluteValue = abs(-5.0); // absoluteValue будет равен 5.0
    ```
*   **`pow(x, y)`:** Возводит `x` в степень `y` (x<sup>y</sup>).
    ```glsl
    float power = pow(2.0, 3.0); // power будет равен 8.0
    ```
*   **`sqrt(x)`:** Возвращает квадратный корень из `x`.
    ```glsl
    float squareRoot = sqrt(9.0); // squareRoot будет равен 3.0
    ```
*   **`exp(x)`:** Возвращает e<sup>x</sup>.
    ```glsl
    float exponent = exp(2.0);//Возвращает значение e в степени 2
    ```
*   **`log(x)`:** Возвращает натуральный логарифм `x`.
    ```glsl
    float logarithm = log(10.0);//Возвращает натуральный логарифм числа 10
    ```
*   **`min(x, y)`:** Возвращает меньшее из двух значений `x` или `y`.
    ```glsl
    float minimum = min(5.0, 3.0); // minimum будет равен 3.0
    ```
*   **`max(x, y)`:** Возвращает большее из двух значений `x` или `y`.
    ```glsl
    float maximum = max(5.0, 3.0); // maximum будет равен 5.0
    ```
*   **`clamp(x, minVal, maxVal`:** Ограничивает значение `x` диапазоном от `minVal` до `maxVal`. Если `x` меньше `minVal`, возвращает `minVal`. Если `x` больше `maxVal`, возвращает `maxVal`.
    ```glsl
    float clamped = clamp(15.0, 0.0, 10.0); // clamped будет равен 10.0
    ```
* **`sin(x)`, `cos(x)`, `tan(x)`**: Тригонометрические функции.
    ```glsl
        float sinValue = sin(1.57);
        float cosValue = cos(0.0);
        float tanValue = tan(0.78);
    ```
* **`abs(x)`**: Вычисляет абсолютное значение.
    ```glsl
    float value = abs(-5.0); //значение будет равно 5.0
    ```

### 7.2 Геометрические Функции

*   **`length(v)`:** Возвращает длину вектора `v`.
    ```glsl
    vec3 myVector = vec3(1.0, 2.0, 3.0);
    float vectorLength = length(myVector);
    ```
*   **`distance(p1, p2)`:** Возвращает расстояние между точками `p1` и `p2`.
    ```glsl
    vec3 point1 = vec3(0.0, 0.0, 0.0);
    vec3 point2 = vec3(1.0, 1.0, 1.0);
    float dist = distance(point1, point2);
    ```
*   **`dot(v1, v2)`:** Возвращает скалярное произведение векторов `v1` и `v2`.
    ```glsl
    vec3 vector1 = vec3(1.0, 0.0, 0.0);
    vec3 vector2 = vec3(0.0, 1.0, 0.0);
    float dotProduct = dot(vector1, vector2);
    ```
*   **`cross(v1, v2)`:** Возвращает векторное произведение векторов `v1` и `v2`.
     ```glsl
    vec3 vector1 = vec3(1.0, 0.0, 0.0);
    vec3 vector2 = vec3(0.0, 1.0, 0.0);
    vec3 crossProduct = cross(vector1, vector2);
    ```
*   **`normalize(v)`:** Нормализует вектор `v` (делает его длину равной 1).
    ```glsl
    vec3 myVector = vec3(1.0, 2.0, 3.0);
    vec3 normalizedVector = normalize(myVector);
    ```
* **`reflect(I, N)`**: Возвращает вектор отражения.
    ```glsl
    vec3 I = vec3(1.0,0.0,0.0);
    vec3 N = vec3(0.0,1.0,0.0);
    vec3 R = reflect(I,N);
    ```

### 7.3 Векторные Функции

*   **`mix(x, y, a)`:** Смешивает значения `x` и `y` в пропорции `a`. `a` должен быть в диапазоне от `0.0` до `1.0`.
    ```glsl
    float color = mix(0.0, 1.0, 0.5); // Смешаем 0.0 и 1.0 на половину, получим 0.5.
    vec3 mixedColor = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.5);//Смешаем красный и зелёный на 50%
    ```
*   **`clamp(x, minVal, maxVal`:** Уже была в математических, но она работает и с векторами. Ограничивает значения компонентов вектора диапазоном от `minVal` до `maxVal`.
```glsl
vec3 color = vec3(0.5,1.5,0.3);
vec3 clampedColor = clamp(color, vec3(0.0), vec3(1.0));// Ограничим значения ветора между 0 и 1
```
* **`step(edge, x)`**: если x < edge, то возвращает 0.0, если x>=edge то возвращает 1.0.
```glsl
float result = step(0.5,0.3);//0.3 меньше 0.5, значит получим 0.0
float result2 = step(0.5,0.7);//0.7 больше 0.5, значит получим 1.0
```
* **`smoothstep(edge0, edge1, x)`**: Если x < edge0 то возвращает 0.0, если x > edge1 то возвращает 1.0, если x между edge0 и edge1 то производит плавную интерполяцию между 0.0 и 1.0.
```glsl
float result = smoothstep(0.0,1.0,0.5);// Получим значение между 0 и 1
```

### 7.4 Текстурные Функции

Текстурные функции используются для работы с текстурами в GLSL. Текстуры — это изображения, которые можно накладывать на поверхности объектов для добавления деталей и реалистичности.

*   **`texture(sampler, coord)`:**  Это основная функция для выборки цвета из текстуры.
    *   **`sampler`:**  Семплер — это переменная непрозрачного типа, которая указывает на текстуру.  Например, `uniform sampler2D myTexture;` (двумерная текстура). Существуют разные типы семплеров в зависимости от типа текстуры.
    *   **`coord`:**  Координаты точки в текстуре, откуда нужно получить цвет.  Тип координат зависит от типа текстуры. Например, для `sampler2D` это `vec2`, для `sampler3D` это `vec3`, для `samplerCube` это `vec3`.
        ```glsl
            uniform sampler2D myTexture; // Семплер для двумерной текстуры.
            vec2 texCoord = vec2(0.5, 0.5); // Координаты (u, v) - центр текстуры.
            vec4 texColor = texture(myTexture, texCoord); // Получаем цвет из текстуры.
        ```
    * **Важно**: В функцию текстур, нельзя передавать координаты которые больше 1.0 или меньше 0.0, в этом случае GLSL будет вести себя не предсказуемо.

* **`textureSize(sampler,lod)`:** Позволяет узнать размеры текстуры.
    * `sampler`: Название семплера.
    * `lod`: Уровень детализации текстуры (Mipmap). Если 0, то самый подробный уровень.
    ```glsl
    uniform sampler2D myTexture;
    ivec2 texSize = textureSize(myTexture,0);//получаем размер 2D текстуры
    ivec3 texSize3D = textureSize(my3DTexture,0);//получаем размер 3D текстуры
    ```
* **`texelFetch(sampler,coords,lod)`**: Позволяет получить значение из текстуры, по точным координатам.
    * `sampler`: Семплер текстуры.
    * `coords`: Координаты пикселя, куда надо получить значение. Тип `ivec*`.
    * `lod`: Уровень детализации.
    ```glsl
    uniform sampler2D myTexture;
    ivec2 coord = ivec2(10,5); //координаты пикселя из которого надо получить значение.
    vec4 texColor = texelFetch(myTexture,coord,0);//получаем цвет пикселя из 2D текстуры.
    ivec3 coord3D = ivec3(1,2,3);
    vec4 color3D = texelFetch(my3DTexture,coord3D,0);//получаем цвет пикселя из 3D текстуры.
    ```
* **`textureProj(sampler, coords)`**: Похожа на функцию `texture`, но она использует проективные текстурные координаты.
     *   **Пример:**
         ```glsl
         uniform sampler2D shadowMap;
         vec4 projCoord = vec4(0.5, 0.5, 0.5, 1.0); // Проективные координаты.
         vec4 shadowColor = textureProj(shadowMap, projCoord);
         ```
* **`textureLod(sampler,coords,lod)`**: Позволяет указать уровень детализации. В данном случае `lod` это уровень детализации. 0 - это самый детальный.
    ```glsl
    uniform sampler2D myTexture;
    vec4 texColor = textureLod(myTexture, vec2(0.5,0.5), 1.0); // Получаем цвет с уровнем детализации 1.0
    ```

### 7.5 Итог

В этом разделе мы рассмотрели лишь некоторые из встроенных функций GLSL. Существует ещё множество других полезных функций. С ними можно ознакомится в документации. Встроенные функции значительно упрощают разработку шейдеров и позволяют создавать сложные эффекты с меньшими усилиями.

**Что дальше?**

В следующем разделе мы рассмотрим препроцессорные директивы GLSL.

## 8. Препроцессор

Препроцессор — это специальная программа, которая обрабатывает GLSL-код *до* его компиляции. Препроцессор выполняет директивы, которые начинаются с символа `#`.  Эти директивы позволяют, например, определять константы, делать условную компиляцию или подключать другие файлы.

### 8.1 `#define` и `#undef` (Определение и Отмена Определения)

*   **`#define`:** Используется для определения констант или макросов.
    *   **Константы:** Простые значения, которые не меняются в коде.
        ```glsl
        #define MAX_LIGHTS 8
        #define PI 3.14159
        ```
        В этих примерах `MAX_LIGHTS` и `PI` — это константы.
    * **Макросы**: Позволяют создавать блоки кода, которые будут подставляться в нужное место.
        ```glsl
        #define SQR(x) ((x) * (x)) // Макрос для возведения в квадрат
        float myVar = SQR(5.0); //после препроцессора превратится в myVar = ((5.0)*(5.0));
        ```
*   **`#undef`:** Отменяет определение константы или макроса.
    ```glsl
    #undef MAX_LIGHTS
    ```

### 8.2 `#if`, `#elif`, `#else`, `#endif` (Условная Компиляция)

Эти директивы используются для условной компиляции. Это значит, что определённые блоки кода будут добавлены или пропущены в зависимости от условий.
```glsl
#define USE_TEXTURES // Определяем константу
#define USE_SHADOWS

#if defined(USE_SHADOWS)
    // Код для отрисовки теней.
#elif defined(USE_FOG)
    // Код для тумана.
#else
    // Код для отрисовки без доп. эффектов.
#endif

#undef USE_SHADOWS // отменяем переменную USE_SHADOWS.
#if defined(USE_SHADOWS)
// Эта часть кода проигнорируется, так как USE_SHADOWS больше не определена
#endif
#if defined(USE_TEXTURES) && defined(USE_FOG)
//Код выполнится если определены обе константы.
#endif

#if defined(USE_TEXTURES) || defined(USE_FOG)
//Код выполнится если определена хотя бы одна из констант.
#endif

```

### 8.3 `#ifdef`, `#ifndef` (Проверка Определения)

*   **`#ifdef`:** Проверяет, определена ли константа.

    ```glsl
    #ifdef USE_TEXTURE
    // Этот код будет включен, если определена константа USE_TEXTURE.
    //К примеру тут можно добавить код для работы с текстурой.
    #endif
    ```

*   **`#ifndef`:** Проверяет, *не* определена ли константа.

    ```glsl
    #ifndef MAX_LIGHTS
        #define MAX_LIGHTS 8
    #endif
     //Если MAX_LIGHTS не определена, то мы её создаём.
    ```

### 8.4 `#error`, `#warning` (Ошибки и Предупреждения)

*   **`#error`:**  Генерирует ошибку компиляции.

    ```glsl
    #error Compilation error!
    ```

*   **`#warning`:** Генерирует предупреждение компиляции.

    ```glsl
    #warning Check this code!
    ```

### 8.5 `#include` (Подключение Файлов)

Директива `#include` позволяет подключать содержимое другого файла.

```glsl
#include "my_utils.glsl"
```

### 8.6 `#extension` (Расширения)

Эта директива включает или отключает GLSL-расширения.

```glsl
#extension GL_ARB_separate_shader_objects : enable
```
    В этом случае мы включили `GL_ARB_separate_shader_objects` расширение.

### 8.7 `#version` (Версия GLSl

Как мы уже знаем из предыдущего раздела, директива `#version` должна быть в самом начале кода. Она указывает версию GLSL и профиль, которые мы будем использовать.
   
```glsl
#version 450 core
```

### 8.8 Итог

Препроцессор — мощный инструмент, который позволяет гибко настраивать код GLSL, создавать константы, делать условную компиляцию и многое другое.

**Что дальше?**

В следующем разделе мы рассмотрим комментарии и кодстайл в GLSL.

## 9. Комментарии и Кодстайл

Комментарии и кодстайл — это важные аспекты любого языка программирования, включая GLSL.  Они делают код более понятным, читаемым и поддерживаемым.  В этом разделе мы рассмотрим, как правильно комментировать код в GLSL и какие правила кодстайла рекомендуется соблюдать.

### 9.1 Комментарии

Комментарии — это пояснения к коду, которые игнорируются компилятором. Они нужны для того, чтобы разработчики (в том числе и ты сам в будущем) могли лучше понять, что делает код.

*   **Однострочные комментарии:** Начинаются с `//`. Всё, что написано после `//` до конца строки, будет считаться комментарием.
    ```glsl
    int count = 0; // Это комментарий.
    ```
*   **Многострочные комментарии:**  Начинаются с `/*` и заканчиваются `*/`. Всё, что находится между `/*` и `*/`, считается комментарием.
    ```glsl
    /*
    Это многострочный комментарий.
    Его можно писать на нескольких строках.
    */
    ```

**Как правильно использовать комментарии:**

*   **Объясняйте сложные части кода:** Если какой-то код может быть неочевидным, напишите комментарий, поясняющий, что он делает.
*   **Не комментируйте очевидное:** Не нужно писать комментарии к простым операциям, которые и так понятны из кода.
* **Оформление**: Старайтесь оформлять комментарии так, что бы они были отделены от кода пробелами.
*   **Пишите комментарии во время написания кода:**  Не откладывайте это на потом.
* **Изменяйте комментарии**: Если вы меняете код, не забывайте менять и комментарии, что бы они были актуальными.

### 9.2 Кодстайл

Кодстайл — это набор правил оформления кода. Следование кодстайлу делает код более читаемым и понятным для других разработчиков, а также помогает избежать ошибок.

**Основные правила кодстайла в GLSL:**

*   **Имена переменных, функций и структур:**
    *   Используйте осмысленные имена, которые описывают назначение переменной или функции (например, `playerSpeed` вместо `a`, `calculateDistance` вместо `foo`.
    * Придерживайтесь единого стиля, например верблюжий регистр `myVariable` или нижнее подчеркивание `my_variable`.
    * Старайтесь избегать слишком длинных имён.
*   **Пробелы:**
    *   Используйте пробелы вокруг операторов `a + b`, а не `a+b`.
    *   Ставьте пробелы после запятых в списках параметров функций `void myFunction(int a, int b)`.
    * Делайте отступы и пробелы что бы код не сливался.
*   **Отступы:**
    *   Используйте отступы (обычно 4 пробела или табуляция), чтобы показать вложенность кода в функциях, циклах и условиях.
* **Оформление**: Для того что бы было удобнее читать, старайтесь делать отступы.
*   **Комментарии:**
    *   Пишите комментарии на английском языке, если код предназначен для совместной разработки.
    *   Начинайте комментарии с заглавной буквы.
* **Порядок в коде**: Придерживайтесь порядка в коде. Сначала объявляются все переменные, потом функции, а в самом конце функция `main`.
* **Согласованность**: Придерживайтесь одного стиля на протяжении всего проекта.

**Пример хорошего кодстайла:**

```glsl
// Переменные:
uniform mat4 modelViewProjectionMatrix;
uniform vec3 lightDirection;
in vec3 position;

// Функция для вычисления освещения.
vec3 calculateLighting(vec3 normal, vec3 lightDir){
    //... Тут будет код...
}

void main() {
    vec4 color = vec4(1.0,0.0,0.0,1.0); // красный цвет
    //... Тут происходит магия ...
}
```

### 9.3 Итог

Комментарии и кодстайл — это не просто "украшения", а важные инструменты, которые помогают писать качественный, понятный и поддерживаемый код. Привычка следовать этим правилам приходит со временем и является признаком хорошего программиста.

**Что дальше?**

На этом всё! Поздравляю, ты изучил весь справочник! Теперь ты настоящий GLSL волшебник! Ты можешь создавать свои собственные шейдеры, экспериментировать с кодом и удивлять всех своими творениями. Но помни, что всё приходит с практикой. Не останавливайся на достигнутом! Удачи тебе, юный разработчик!
