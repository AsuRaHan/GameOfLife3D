# Глава 1: Обзор Системы Модов

В этой главе мы рассмотрим основные компоненты системы модов и то, как они взаимодействуют друг с другом для создания гибкой и расширяемой среды для клеточного автомата.

## 1.1. Основные компоненты

Система модов состоит из нескольких ключевых компонентов:

*   **`ModManager`:** Отвечает за управление модами, их загрузку, переключение между ними, чтение конфигурационных файлов (`mod.cfg`, `ui.cfg`).
*   **`ModSystemAutomaton`:** Является ядром системы модов. Реализует логику клеточного автомата, управляет правилами, переменными, загружает шейдеры и визуализирует состояние клеток.
*   **`UIBuilder`:**  Отвечает за динамическое построение пользовательского интерфейса модов, используя данные из файла `ui.cfg`.
*   **`ShaderManager`:**  Управляет загрузкой, компиляцией, линковкой и использованием шейдеров.
* **`GPUAutomaton`**: Является базовым классом для всех клеточных автоматов.

## 1.2. Принцип работы

Система модов работает следующим образом:

1.  **Инициализация:** При старте приложения `ModManager` проверяет наличие папки `mods` и необходимых файлов, и загружает список доступных модов из `mod_list.gmod`.
2.  **Загрузка мода:** Когда пользователь выбирает мод, `ModManager` читает его конфигурацию из файла `mod.cfg`. Затем вызывается `LoadSelectedMod()` в `ModSystemAutomaton`.
3.  **Загрузка шейдера:** `LoadSelectedMod()` в `ModSystemAutomaton` загружает основной шейдер (`main.glsl`) с помощью `ShaderManager`. В процессе загрузки происходит обработка `#include` и макросов `{{groupSizeX}}`, `{{groupSizeY}}`.
4. **Добавление UI:** В `ModSystemAutomaton` вызывается `addUIElementsToVariablesMap()` который берет ui элементы из `ModManager::getCurrentModUIElements()` и добавляет в `variablesMap`.
5. **Обновление шейдера:** Когда вызывается `updateShaderUniforms()` в `ModSystemAutomaton` он обновляет значения переменных в шейдере, на основе данных из `variablesMap`.
6. **Построение UI:** Когда вызывается `UIBuilder::drawUI()` , то отрисовывается UI.
7. **Обновление:** GPUAutomaton::Update() вызывает шейдер для обновления игрового поля.

## 1.3. Жизненный цикл мода

Жизненный цикл мода включает в себя следующие этапы:

1.  **Загрузка:** Приложение стартует, `ModManager` проверяет и загружает доступные моды.
2.  **Выбор мода:** Пользователь выбирает мод из списка. `ModManager` устанавливает текущий мод.
3.  **Инициализация:**
    *   `ModManager` читает конфигурацию мода из `mod.cfg` и устанавливает UI из `ui.cfg`.
    *   `ModSystemAutomaton` загружает и компилирует шейдер (`main.glsl`).
    * `ModSystemAutomaton` вызывает `addUIElementsToVariablesMap()`.
4.  **Обновление:**
    *    Вызывается  `GPUAutomaton::Update()`.
    *   `ModSystemAutomaton::updateShaderUniforms()` обновляет значения uniform переменных в шейдере, на основе `variablesMap`.
    * Шейдер вычисляет новое состояние клеток.
    * Происходит отрисовка и обновление UI.
5.  **Переключение мода:** Пользователь может выбрать другой мод. Тогда происходит повторение шагов 3 и 4 для нового мода.
6.  **Завершение:** Когда пользователь закрывает приложение, все ресурсы, связанные с модами, должны быть освобождены.

## 1.4. Поддержка типов

Система модов поддерживает следующие типы данных:

*   **`int`:** Целочисленные значения.
*   **`float`:** Числа с плавающей точкой.
*   **`bool`:** Логические значения (true/false).
* **`float[]`**: Массивы чисел с плавающей точкой.
* **`sampler2D`**: Семплер текстур.

## 1.5. Папки

Система модов использует следующую структуру папок:

*   **`mods/`:** Основная папка с модами.
    *   **`mod_list.gmod`:** Текстовый файл, содержащий список доступных модов (названия папок модов, по одному на строке).
    *   **`modName/`:** Папка, содержащая файлы конкретного мода (где `modName` — имя мода).
        *   **`mod.cfg`:** Текстовый файл с конфигурацией мода (имя, размеры мира, и т.д.).
        * **`ui.cfg`**: Текстовый файл конфигурации пользовательского интерфейса.
        *   **`main.glsl`:** Основной вычислительный шейдер мода.
        *   **`libs/`:** Необязательная папка для хранения дополнительных `.glsl` файлов, которые можно подключать через `#include` в `main.glsl`.

# Глава 2: Создание и Управление Модами

В этой главе мы рассмотрим, как создавать собственные моды для "Game of Life 3D" и как управлять ими.

## 2.1. Структура Папки Мода

Каждый мод должен располагаться в отдельной папке внутри директории `mods/`. Имя папки будет являться именем мода. Внутри папки мода должны находиться следующие файлы:

*   **`mod.cfg`:** Основной конфигурационный файл мода. Содержит информацию о моде (имя, размеры мира, переменные и т.д.).
*   **`ui.cfg`:** Конфигурационный файл для пользовательского интерфейса мода. Определяет расположение элементов управления.
*   **`main.glsl`:** Основной вычислительный шейдер мода. Содержит логику правил, подсчета соседей и визуализации.
*   **`libs/`:** (Необязательная папка) Дополнительная папка, в которой могут находиться другие `.glsl` файлы с вспомогательными функциями или общими фрагментами кода.

## 2.2. Файл `mod.cfg`

Файл `mod.cfg` содержит основную информацию о моде. Он использует простой формат "ключ=значение;". Каждая строка в файле должна быть в формате `имя_переменной=тип;значение`.

### Возможные параметры:

*   **`modName`**: Имя мода. Должно совпадать с именем папки мода.
    *   **Тип:** `string`
    *   **Пример:** `modName=genesis;`
*   **`minWorldSizeX`**: Минимальный размер мира по оси X.
    *   **Тип:** `int`
    *   **Пример:** `minWorldSizeX=int;100`
*   **`minWorldSizeY`**: Минимальный размер мира по оси Y.
    *   **Тип:** `int`
    *   **Пример:** `minWorldSizeY=int;100`
*   **`minWorldSizeZ`**: Минимальный размер мира по оси Z. (пока не используется)
    *   **Тип:** `int`
    *   **Пример:** `minWorldSizeZ=int;1`

### 2.3. переменные

*   В `mod.cfg` можно задавать переменные, которые будут доступны в UI и в шейдере.
* Переменные должны быть описаны в формате `name=type;value`
* **`name`** имя переменной, будет доступно в UI и в шейдере.
* **`type`** тип переменной.
* **`value`** значение переменной.

### Поддерживаемые типы переменных:

* **`int`** целое число.
    * **Пример:** `myInt=int;10`
* **`float`** число с плавающей точкой.
    * **Пример:** `myFloat=float;0.5`
* **`bool`** булевая переменная.
   * **Пример:** `myBool=bool;true`

### Пример файла `mod.cfg`
```
modName=genesis; 
minWorldSizeX=int;100 
minWorldSizeY=int;100 
minWorldSizeZ=int;1 
starvingTicks=int;10 
mutantChance=float;0.0005 
reproduceEnergyThreshold=float;0.8 
energyCostPerTick=float;0.001 
reproduceEnergyCost=float;0.4 
energyPerPrey=float;0.2 
energyAbsorbed=float;0.005 
startEnergy=float;1.0 
energyFromDead=float;0.15
```

## 2.3. Файл `ui.cfg`

Файл `ui.cfg` отвечает за расположение элементов управления в пользовательском интерфейсе мода. Он также использует формат "ключ=значение;". Каждая строка в файле описывает один элемент управления в формате `id=type;name;value;`.

### Возможные параметры:

*   **`id`**: Уникальный идентификатор элемента.
    *   **Тип:** `int`
    *   **Пример:** `1=InputInt;birth;3;`
*   **`type`**: Тип элемента управления.
    *   **Тип:** `string`
    *   **Возможные значения:**
        *   `Separator`: Разделитель.
            * **Пример**: `2=Separator;;`
        *   `InputText`: Текстовое поле.
            * **Пример**: `3=InputText;modName;genesis;`
        *   `InputInt`: Поле для ввода целого числа.
            * **Пример**: `1=InputInt;birth;3;`
        *   `InputFloat`: Поле для ввода числа с плавающей точкой.
           * **Пример**: `4=InputFloat;energyPerPrey;0.2;`
        * `Text`: Текст.
           * **Пример**: `5=Text;Hello world;`
    *   **`name`**: Имя переменной или текста.
        *  **Тип:** `string`
    * `value` Значение переменной или текста.
        *  **Тип:** `string` или `int` или `float`.

### Пример файла `ui.cfg`

1=InputInt;birth;3; 2=InputInt;survivalMin;2; 3=InputInt;survivalMax;3; 4=InputInt;overpopulation;4; 5=Separator;; 6=InputFloat;mutantChance;0.0005; 7=InputInt;starvingTicks;10; 8=InputFloat;reproduceEnergyThreshold;0.8; 9=InputFloat;energyCostPerTick;0.001; 10=InputFloat;reproduceEnergyCost;0.4; 11=InputFloat;energyPerPrey;0.2; 12=InputFloat;energyAbsorbed;0.005; 13=InputFloat;startEnergy;1.0; 14=InputFloat;energyFromDead;0.15; 15=Text;Hello world;; 16=InputText;modName;genesis;


## 2.4. Файл `main.glsl`

Файл `main.glsl` - это основной вычислительный шейдер мода. Он написан на языке GLSL (OpenGL Shading Language). Этот файл определяет логику поведения клеток, правила их взаимодействия, подсчет соседей и визуализацию.

### Макросы

*   **`{{groupSizeX}}`:** Заменяется на размер группы по оси X (определяется в коде на C++).
*   **`{{groupSizeY}}`:** Заменяется на размер группы по оси Y (определяется в коде на C++).

### Система правил

В шейдере реализованы две системы правил:

*   **Стандартный режим:** Классические правила "Игры Жизнь" (можно настроить `birth`, `survivalMin`, `survivalMax`, `overpopulation`).
*   **Расширенный режим:** Более гибкая система правил, где для каждого количества соседей можно задать, должна ли клетка родиться, выжить или умереть от перенаселения (`birthCounts`, `surviveCounts`, `overpopulationCounts`).

### Функции подсчёта соседей

*   **`countLiveNeighbors(ivec2 pos, int targetType)`:** Подсчитывает количество живых соседей вокруг клетки.
    *   **`pos`:** Позиция клетки.
    *   **`targetType`:** Тип соседей, которых нужно считать:
        *   `0` - все живые соседи.
        *   `>0` - количество соседей указанного типа.
* **`countDeadNeighbors(ivec2 pos)`** Подсчитывает количество мертвых соседей вокруг клетки.
    *   **`pos`**: Позиция клетки.

### Функция определения типа клетки

*   **`determineNewType(ivec2 pos)`:** Определяет тип новорождённой клетки на основе типов её соседей.
    *   **`pos`:** Позиция, где рождается клетка.

### Система визуализации клеток

*   **`getColorByType(int type, int currentState, float energy)`:** Определяет цвет клетки в зависимости от её типа.
    *   **`type`:** Тип клетки.
    * **`currentState`**: Текущие состояние клетки.
    * **`energy`**: Текущие энергии клетки.
    *   Возвращает `vec4` (цвет и энергию).

### Логика поведения клеток

В функции `main()` реализована логика поведения клеток:

*   **Хищники:** Охотятся на жертв, перемещаются к ним, умирают от голода.
* **Травоядные:**  Охотятся на растения, перемещаются к ним, умирают от голода.
* **Падальщики:**  Едят мёртвые клетки, не перемещаются, умирают от голода.
* **Энергетические растения:** Поглощают энергию.
* **Мины:** Уничтожают все на своём пути, самоуничтожаются.
* **Размножение:** Клетки размножаются при достижении определенного порога энергии.
* **Мутации:** Клетки могут мутировать в другой тип.
* **Стандартные и расширенные правила:** Реализация правил рождения, выживания и перенаселения.

### Переменные

* Переменные объявляются как `uniform` .
* **Пример:** `uniform int myInt;`
* Имя переменной будет доступно из `ui.cfg` и `mod.cfg`.

### Пример части кода main.glsl
```glsl
uniform int starvingTicks = 10; // Количество шагов без еды, после которых хищник умирает
uniform float mutantChance = 0.0005; // Шанс мутации клетки в другой тип (от 0.0 до 1.0)
```

## 2.5. Папка `libs/`

*   Папка `libs/` внутри папки мода является необязательной.
*   Она предназначена для хранения дополнительных `.glsl` файлов с вспомогательными функциями, структурами, константами или общими фрагментами кода, которые могут использоваться в `main.glsl`.
*   Использование этой папки помогает организовать код и избежать дублирования.
* В папке `libs/` вы можете создать структуру с разными папками.
* **Подключение:** Для подключения `.glsl` файла из этой папки используется директива `#include`. Путь к файлу указывается в двойных кавычках относительно корневой папки мода или в самой папке `libs/`.
*   **Примеры:**
    *   Подключение файла `my_funcs.glsl` из папки `libs`:
        ```glsl
        #include "my_funcs.glsl"
        ```
    * Подключение файла из папки `libs/utils/`
        ```glsl
        #include "utils/my_funcs.glsl"
        ```
* **Поиск файлов:** Сначала система будет искать файл в папке текущего мода. Если файл не найден, то будет поиск в основной папке `libs`.
* **Вложенные include**: Поддержка вложенных `include`.

## 2.6. Установка Мода

Чтобы установить новый мод, выполните следующие шаги:

1.  **Создайте папку для мода:** В директории `mods/` создайте новую папку. Имя папки будет именем вашего мода. *Например, `mods/myAwesomeMod/`*.
2.  **Создайте файл `mod.cfg`:** Внутри папки мода создайте текстовый файл `mod.cfg`. Заполните его необходимыми параметрами, такими как имя мода, размеры мира, начальные значения переменных (см. раздел 2.2).
3.  **Создайте файл `ui.cfg`:** Рядом с `mod.cfg` создайте файл `ui.cfg`. В этом файле опишите элементы пользовательского интерфейса вашего мода (см. раздел 2.3).
4.  **Создайте файл `main.glsl`:** Создайте файл `main.glsl` рядом с `mod.cfg` и `ui.cfg`. Это будет основной вычислительный шейдер вашего мода. В нём вы определите правила поведения клеток, их взаимодействие, визуализацию, используя функции и структуры, описанные в разделе 2.4.
5. **Добавьте include** Если необходимо, создайте папку `libs/` и добавьте туда дополнительные `.glsl` файлы. Укажите путь к ним с помощью `#include` в вашем `main.glsl` файле.
6.  **Добавьте мод в `mod_list.gmod`:** Откройте файл `mod_list.gmod`, находящийся в папке `mods/`. Добавьте в этот файл имя папки вашего мода (по одному имени на строке). *Например, если имя вашей папки `myAwesomeMod`, то добавьте в файл строку `myAwesomeMod`*.
7.  **Запустите игру:** Запустите приложение.
8.  **Выберите ваш мод:** В главном меню выберите ваш новый мод из списка.

**Проверка:**
После выбора мода и запуска игры, убедитесь, что:
* Шейдер загружен без ошибок (проверьте консоль).
* UI отрисован корректно.
* Клетки ведут себя в соответствии с логикой, описанной в вашем шейдере.

**Дополнительные советы:**

*   **Имена:** Используйте осмысленные имена для файлов и папок.
* **Тестирование:** После каждого изменения тестируйте свой мод.
* **Комментарии:** Обильно комментируйте свой код в `main.glsl` и в дополнительных `glsl` файлах.
*   **Отладка:** Если возникают ошибки, проверяйте консоль на наличие сообщений об ошибках.
* **Ошибки:** Если в вашем моде есть ошибки то приложение может зависнуть.
* **Проверки:** Проверьте что вы указали имя папки мода в `mod_list.gmod`
* **`ui.cfg`:** проверьте правильность указания переменных в `ui.cfg`.
* **`mod.cfg`:** проверьте правильность указания переменных в `mod.cfg`.

# Глава 3: Работа с Системой Модов

В этой главе мы подробно рассмотрим, как взаимодействовать с основными компонентами системы модов и как они работают.

## 3.1. `ModManager`

`ModManager` отвечает за управление модами, их загрузку, настройку и переключение между ними.

### Методы:

*   **`checkMods()`:**
    *   **Описание:** Проверяет наличие папки `mods/` и файла `mod_list.gmod`. Создает их, если они отсутствуют.
    *   **Использование:** Вызывается при запуске приложения.
    *   **Возвращаемое значение:** `void`
*   **`getModsFolderPath()`:**
    *   **Описание:** Возвращает путь к папке `mods/`.
    *   **Использование:** Для получения пути к папке с модами.
    *   **Возвращаемое значение:** `std::string`
*   **`getModFilePath(const std::string& filename)`:**
    *   **Описание:** Возвращает полный путь к файлу, находящемуся в текущей папке мода.
    *   **Параметры:**
        *   `filename`: Имя файла.
    *   **Использование:** Для получения пути к файлам мода (например, `mod.cfg`, `ui.cfg`, `.glsl`).
    *   **Возвращаемое значение:** `std::string`
*   **`loadAvailableMods()`:**
    *   **Описание:** Загружает список доступных модов из файла `mod_list.gmod`.
    *   **Использование:** Вызывается при запуске приложения.
    *   **Возвращаемое значение:** `void`
*   **`LoadSelectedMod()`:**
    *   **Описание:** Загружает выбранный мод, читает `mod.cfg`, `ui.cfg` и инициализирует UI. Создаёт список переменных.
    *   **Использование:** Вызывается при выборе мода пользователем.
    *   **Возвращаемое значение:** `void`
*   **`getCurrentModName()`:**
    *   **Описание:** Возвращает имя текущего выбранного мода.
    *   **Использование:** Для получения имени текущего мода.
    *   **Возвращаемое значение:** `std::string`
*   **`setCurrentModName(const std::string& modName)`:**
    *   **Описание:** Устанавливает текущий выбранный мод.
    *   **Параметры:**
        *   `modName`: Имя мода.
    *   **Использование:** Вызывается при выборе мода пользователем.
    *   **Возвращаемое значение:** `void`
*   **`getAvailableMods()`:**
    *   **Описание:** Возвращает список доступных модов.
    *   **Использование:** Для получения списка доступных модов.
    *   **Возвращаемое значение:** `std::vector<std::string>`
*   **`getCurrentModUIElements()`:**
    *   **Описание:** Возвращает список UI элементов текущего мода.
    *   **Использование:** Для получения списка элементов UI.
    *   **Возвращаемое значение:** `const std::vector<UIElement>&`
*   **`getModVariables()`:**
    *   **Описание:** Возвращает список переменных мода из `config.txt`
    *   **Использование:** Для получения переменных мода.
    *   **Возвращаемое значение:** `std::map<std::string, ModVariableInfo>`

## 3.2. `ModSystemAutomaton`

`ModSystemAutomaton` — это ядро системы модов. Он отвечает за логику клеточного автомата, управление правилами, переменными и взаимодействие с шейдерами.

### Методы:

*   **`getModShaderVariables()`:**
    *   **Описание:** Получает список uniform переменных из загруженного шейдера.
    *   **Использование:** Для получения переменных из шейдера.
    *   **Возвращаемое значение:** `std::vector<ShaderVariableInfo>`
*   **`addKnownVariablesToUI()`:**
    *   **Описание:** Добавляет в `variablesMap` известные переменные, которые определены в `mod.cfg`.
    *   **Использование:** После загрузки мода.
    *   **Возвращаемое значение:** `void`
* **`addUIElementsToVariablesMap()`:**
    * **Описание:** Добавляет в `variablesMap` элементы UI, которые определены в `ui.cfg`.
    * **Использование:** После загрузки мода.
    * **Возвращаемое значение:** `void`
*   **`updateShaderUniforms()`:**
    *   **Описание:** Обновляет значения uniform переменных в шейдере на основе данных из `variablesMap` и `ModManager`.
    *   **Использование:** Вызывается, когда нужно обновить uniform переменные, например, после изменения значений в UI.
    *   **Возвращаемое значение:** `void`
*  **`LoadSelectedMod()`**
     * **Описание:** Загружает шейдер, обрабатывает include и макросы.
     * **Использование:** Вызывается при смене мода.
     * **Возвращаемое значение:** `void`
*  **`loadShaderSourceWithIncludes(const std::string& filename)`**
   * **Описание:** Загружает шейдер с поддержкой `#include`.
   * **Использование:** Внутри `LoadSelectedMod()`
   * **Возвращаемое значение:** `std::string`
* **`processShaderMacros(std::string shaderSource)`**
   * **Описание:** Обработка макросов в шейдере.
   * **Использование:** Внутри `LoadSelectedMod()`
   * **Возвращаемое значение:** `std::string`
* **`replaceMacros(std::string source, const std::string& macro, const std::string& value)`**
   * **Описание:** Заменяет макросы.
   * **Использование:** Внутри `LoadSelectedMod()`
   * **Возвращаемое значение:** `std::string`
*   Другие методы для работы с правилами.

## 3.2. `UIBuilder`

`UIBuilder` отвечает за построение пользовательского интерфейса модов.

### Методы:

*   **`loadConfigFromFile(const std::string& filename)`:**
    *   **Описание:** Загружает конфигурацию UI из файла `ui.cfg`.
    *   **Параметры:**
        *   `filename`: Имя файла `ui.cfg`.
    *   **Использование:** Вызывается при загрузке мода.
    *   **Возвращаемое значение:** `bool` (успешно или нет)
*   **`drawUI(bool* p_open, std::map<std::string, ShaderVariableInfo*>& variablesMap)`:**
    *   **Описание:** Отрисовывает UI. Обрабатывает изменения значений в UI.
    *   **Параметры:**
        *   `p_open`: Указатель на флаг, показывающий, открыто ли окно UI.
        *  `variablesMap` переменные для ui.
    *   **Использование:** Вызывается в цикле отрисовки UI.
    *   **Возвращаемое значение:** `void`
*  **`getElements()`**
   *  **Описание:** Получение списка ui элементов.
   * **Возвращаемое значение:** `const std::vector<UIElement>&`

## 3.4. `GPUAutomaton`

`GPUAutomaton` — базовый класс для клеточных автоматов.

### Методы:

*   **`Update()`:**
    *   **Описание:** Обновляет состояние игрового поля, вызывая вычислительный шейдер.
    *   **Использование:** Вызывается в основном цикле приложения.
    *   **Возвращаемое значение:** `void`
*   **`RandomizeGrid(float density, unsigned int seed)`:**
    *   **Описание:** Рандомизирует состояние игрового поля.
    *   **Параметры:**
        *   `density`: Плотность заполнения (от 0.0 до 1.0).
        *  `seed`: Значение для генератора псевдослучайных чисел.
    *   **Использование:** Вызывается для начальной инициализации поля или при желании его рандомизировать.
    *   **Возвращаемое значение:** `void`
*   **`ClearGrid()`:**
    *   **Описание:** Очищает игровое поле.
    *   **Использование:** Вызывается для очистки поля.
    *   **Возвращаемое значение:** `void`

## 3.5. Переменные

* **`ShaderVariableInfo`** Структура, содержащая информацию о uniform переменной.
 * **`name`** имя переменной.
 * **`location`** положение переменной.
 * **`type`** тип переменной.
 * **`arraySize`** размер массива.
 * **`callback`** callback функция.
 * **`value`** значение переменной.
 * **`valueStr`** значение в виде строки.
 * **`min`** минимальное значение.
 * **`max`** максимальное значение.
 * **`values`** Массив значений.

* **`ModVariableInfo`** Структура, содержащая информацию о переменной в `mod.cfg`.
 * **`type`** тип переменной.
 * **`value`** значение переменной.

## 3.6. `ShaderManager`

`ShaderManager` отвечает за загрузку, компиляцию и управление шейдерами.

### Методы:

*   **`getProgram(const std::string& programName)`:**
    *   **Описание:** Возвращает ID скомпилированной и слинкованной программы.
    *   **Параметры:**
        *   `programName`: Имя программы.
    *   **Использование:** Для получения ID программы шейдера.
    *   **Возвращаемое значение:** `GLuint`
* Другие функции для работы с шейдером.

# Глава 4: Расширение Системы Модов (Для Разработчиков)

Эта глава предназначена для разработчиков, которые хотят расширить функциональность системы модов, добавив новые возможности, типы переменных, элементы UI или изменив существующую логику.

## 4.1. Добавление Новых Типов Переменных

Система модов поддерживает типы `int`, `float`, `bool`, `float[]` и `sampler2D`. Чтобы добавить поддержку нового типа данных, вам потребуется:

1.  **Изменить `ShaderVariableInfo`:**
    *   Добавьте новое поле в `union value` в структуре `ShaderVariableInfo` (см. `ModSystemAutomaton.h`).
    *   Если нужен `array` для нового типа данных добавьте в `ShaderVariableInfo` новый `std::vector`.
2.  **Изменить `ModSystemAutomaton::addKnownVariablesToUI()`:**
    *   Добавьте новый `case` в `switch`, чтобы обрабатывать новый тип, если он нужен в `mod.cfg`.
    *   Добавьте обработку нового типа в `callback`.
    *   Добавьте обработку нового типа в `updateShaderUniforms()`.
3.  **Изменить `ModSystemAutomaton::addUIElementsToVariablesMap()`:**
    * Добавить новый тип в `ui.cfg`.
    *   Добавить новый `case` в `switch`, чтобы обрабатывать новый тип.
    *   Добавить обработку нового типа в `callback`.
4.  **Изменить `ModSystemAutomaton::updateShaderUniforms()`:**
    *   Добавьте новый `case` в `switch`, чтобы вызывать соответствующую функцию `glUniform...` для установки значения в шейдере.
5.  **Изменить `UIBuilder::drawUI()`:**
    *   Добавьте новый тип UI элемента.
    *   Добавьте новый `case` в `switch`, чтобы рисовать UI для нового типа.
    *   Добавьте обработку `callback` для нового типа.
6. **Изменить `ModManager::LoadSelectedMod()`**
    * Добавить обработку нового типа, если нужно в `mod.cfg`.
7. **Добавить новый тип в `main.glsl`**
   * Добавить поддержку нового типа в шейдер.
8. **Добавить новый тип в документацию**
 * Описать новый тип в главе 1 и 2.

## 4.2. Расширение UI

Чтобы добавить новый тип элемента UI, вам потребуется:

1.  **Добавить новый `enum UIElementType`:** Добавьте новый элемент в перечисление `UIElementType` в `UIBuilder.h`.
2.  **Изменить `UIBuilder::drawUI()`:** Добавьте новый `else if` блок, который будет рисовать новый UI элемент с помощью ImGui, используя `variablesMap`.
3. **Добавить в документацию**
 * Описать новый тип в главе 2 и 3.
4. **Добавить новый тип в `ui.cfg`**
 * Указать новый тип в `ui.cfg`.

## 4.3. Добавление Новой Логики Клеток

Чтобы добавить новые правила поведения клеток, вам нужно будет изменить файл `main.glsl`.

1.  **Функции подсчёта соседей:**
    *   Вы можете добавлять свои функции подсчёта соседей, похожие на `countLiveNeighbors()` и `countDeadNeighbors()`.
2.  **Функция определения типа клетки:**
    *   Вы можете изменить `determineNewType()` или добавить свою функцию, определяющую тип новорождённой клетки.
3.  **Логика поведения клеток (`main()`):**
    *   Добавьте новые блоки `if` или `else if`, чтобы реализовать новую логику для существующих или новых типов клеток.
    *   Используйте переменные `currentState` (текущий тип клетки) и `neighbors` (количество живых соседей) для принятия решений.
    * Используйте переменные `currentEnergy`  (текущие энергия клетки), `nextEnergy` (следующие значение энергии).
    *  Используйте функцию `countLiveNeighbors()` и `countDeadNeighbors()`.
    *  Используйте функцию `getColorByType()` для определения цвета клетки.
    *  Используйте функцию `determineNewType()` для определения типа клетки.
    * Используйте функцию `canMoveTo()` для перемещения клетки.
    *  Используйте функцию  `canBeBorn()`, `canSurvive()`, `isOverpopulated()` для расширенных правил.
4. **Новые типы:** Вы можете добавить новый тип клетки изменив функции:
    * `determineNewType()`
    * `getColorByType()`
    * `countLiveNeighbors()`
    * Добавить логику в `main()`.
    * Добавить новый цвет в `getColorByType()`
5. **Переменные:**
    *  Вы можете добавлять свои переменные, используя `uniform`.
    * Имя переменной должно быть уникальным.
    * Пример: `uniform int myInt;`
6. **Добавить в документацию**
 * Описать ваши новые функции и типы в главе 2.4.
 * Описать ваши новые функции в главе 3.

## 4.4. Добавление новых параметров в `mod.cfg`

1. **Изменить `ModManager::LoadSelectedMod()`:**
   * Добавить обработку нового типа, если нужно.
   * Добавить новую переменную в `ModVariableInfo`.
2.  **Добавить в документацию**
  * Описать новый тип в главе 2.2.
  * Описать новый метод в главе 3.1.

## 4.5. Добавление новых параметров в `ui.cfg`

1. **Добавить новый тип в `ui.cfg`**
 * Указать новый тип в `ui.cfg`.
2. **Изменить `UIBuilder::drawUI()`:**
 * Добавить обработку нового типа.
3. **Изменить `ModSystemAutomaton::addUIElementsToVariablesMap()`:**
 * Добавить обработку нового типа.
4. **Добавить в документацию**
 * Описать новый тип в главе 2.3.
 * Описать новый метод в главе 3.3.

## 4.6 Как загрузить новый шейдер

1.  **Создайте файл шейдера:** Напишите свой шейдер на GLSL.
2.  **Поместите шейдер в папку мода:** Поместите файл вашего шейдера в папку мода, например, в корневую папку или в папку `libs/`.
3. **Изменить `main.glsl`** Если нужно измените `main.glsl`.
4.  **`#include` (опционально):** Если нужно, подключите вспомогательные файлы с помощью `#include` в `main.glsl`.
5.  **Изменить `ModSystemAutomaton::CreateComputeShader()`**
    * Добавьте код для загрузки вашего нового шейдера.
    * Измените `computeProgram`.
    * Измените `clearProgram`.
    * Измените `randomizeProgram`.
    * Создайте функцию для загрузки шейдера.
6.  **Вызовите загрузку шейдера:** Вызовите функцию загрузки шейдера в `ModSystemAutomaton::LoadSelectedMod()`.
7. **Добавить в документацию**
 * Описать ваш новый шейдер в главе 2.4.
 * Описать ваш новый метод в главе 3.2.
 * Описать измененные методы в главе 3.2.

# Заключение

Система модов для "Game of Life 3D" предоставляет широкие возможности для изменения и расширения базового функционала игры. Она позволяет создавать новые правила, типы клеток, изменять визуализацию и добавлять элементы управления, не затрагивая основной код приложения.

**Итоги**

В ходе разработки этой системы были реализованы следующие ключевые возможности:

*   **Гибкое управление модами:** `ModManager` обеспечивает простую и удобную загрузку, выбор и переключение между модами.
*   **Динамическое построение UI:** `UIBuilder` позволяет создавать пользовательский интерфейс, загружая его описание из `ui.cfg`, что обеспечивает большую гибкость в настройке.
*   **Использование шейдеров:** `ShaderManager` эффективно управляет загрузкой, компиляцией и использованием шейдеров, что позволяет реализовывать сложную логику и визуальные эффекты.
*   **Поддержка различных типов данных:** Система поддерживает основные типы данных (`int`, `float`, `bool`, `float[]`, `sampler2D`), что позволяет создавать разнообразные правила и механики.
*   **Добавление переменных:** Добавление переменных через `mod.cfg`, `ui.cfg` и `main.glsl`.
* **`include`**: Подключение внешних файлов.
* **`Macro`**: Использование макросов в шейдере.
* **Разделение логики**: Разделение логики для пользователей, моддеров и разработчиков.
*   **Расширяемость:** Система спроектирована с учётом возможности добавления новых типов переменных, UI элементов и правил поведения клеток.
* **Простота:** Простота установки мода.

**Дальнейшие планы**

В дальнейшем планируется:

*   **Расширение функционала UI:** Добавление новых типов элементов управления (например, ползунков, выпадающих списков, кнопок).
* **Добавление новых типов:** Добавление новых типов данных.
*   **Оптимизация:** Оптимизация загрузки шейдеров и работы с `variablesMap`.
*   **Поддержка 3D:** Адаптация системы для работы с трёхмерными клеточными автоматами.
*   **Сетевые возможности:** Добавление сетевых возможностей для создания многопользовательских симуляций.
* **Редактор модов:** Создание редактора модов для упрощения создания модов.
* **И другое**

Мы надеемся, что эта система модов откроет широкие возможности для творчества и позволит создавать множество уникальных и интересных симуляций в "Game of Life 3D".

